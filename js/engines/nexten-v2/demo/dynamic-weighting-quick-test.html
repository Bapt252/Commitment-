<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NEXTEN V2.0 - Test Rapide Pond√©ration Dynamique</title>
    <style>
        body { font-family: Arial, sans-serif; max-width: 1200px; margin: 0 auto; padding: 20px; }
        .header { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 20px; border-radius: 10px; text-align: center; margin-bottom: 20px; }
        .section { background: #f8f9fa; padding: 20px; border-radius: 10px; margin-bottom: 20px; border-left: 4px solid #667eea; }
        .btn { background: #667eea; color: white; border: none; padding: 12px 20px; border-radius: 6px; cursor: pointer; margin: 5px; }
        .btn:hover { background: #5a6fd8; }
        .btn-success { background: #22c55e; }
        .btn-warning { background: #f59e0b; }
        .result { background: white; padding: 15px; border-radius: 8px; margin: 10px 0; border: 1px solid #e5e7eb; }
        .motivation-item { display: inline-block; margin: 5px; padding: 8px 12px; background: #e5e7eb; border-radius: 15px; cursor: pointer; }
        .motivation-item.selected { background: #667eea; color: white; }
        .score-display { text-align: center; font-size: 2em; font-weight: bold; margin: 20px; padding: 20px; background: white; border-radius: 10px; }
        .criteria-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 10px; }
        .criteria-item { background: white; padding: 10px; border-radius: 8px; border-left: 4px solid #667eea; }
        pre { background: #f1f5f9; padding: 10px; border-radius: 6px; overflow-x: auto; font-size: 12px; }
        .comparison { display: grid; grid-template-columns: 1fr 1fr; gap: 20px; }
        .hidden { display: none; }
    </style>
</head>
<body>
    <div class="header">
        <h1>üéØ NEXTEN V2.0 - Test Rapide Pond√©ration Dynamique</h1>
        <p>Version all√©g√©e pour test imm√©diat du syst√®me r√©volutionnaire</p>
    </div>

    <div class="section">
        <h2>üë§ Configuration Candidat</h2>
        <p>S√©lectionnez les motivations par ordre de priorit√© (3 max) :</p>
        <div id="motivationSelector">
            <div class="motivation-item" data-motivation="remuneration">üí∞ R√©mun√©ration</div>
            <div class="motivation-item" data-motivation="localisation">üìç Localisation</div>
            <div class="motivation-item" data-motivation="flexibilite">üè† Flexibilit√©</div>
            <div class="motivation-item" data-motivation="perspectives_evolution">üìà Perspectives √©volution</div>
            <div class="motivation-item" data-motivation="autre">üéØ Autre</div>
        </div>
        <p><strong>Motivations s√©lectionn√©es :</strong> <span id="selectedMotivations">Aucune</span></p>
    </div>

    <div class="section">
        <h2>‚öñÔ∏è Test Pond√©ration Dynamique</h2>
        <button class="btn btn-success" onclick="testDynamicWeighting()">üß™ Tester Pond√©ration Dynamique</button>
        <button class="btn btn-warning" onclick="runAllTests()">üî¨ Lancer Tests Complets</button>
        <button class="btn" onclick="showComparison()">üìä Comparer Avant/Apr√®s</button>
    </div>

    <div id="results" class="section hidden">
        <h2>üìä R√©sultats</h2>
        <div id="resultsContent"></div>
    </div>

    <div id="comparison" class="section hidden">
        <h2>üìà Comparaison Avant/Apr√®s Pond√©ration</h2>
        <div class="comparison" id="comparisonContent"></div>
    </div>

    <script>
        // === SYST√àME DE POND√âRATION DYNAMIQUE ALL√âG√â ===
        
        const baseWeights = {
            semantic: 0.205,           // 20.5%
            compensation: 0.196,       // 19.6%
            location: 0.161,           // 16.1%
            motivation: 0.107,         // 10.7%
            companySize: 0.071,        // 7.1%
            workEnvironment: 0.071,    // 7.1%
            industry: 0.054,           // 5.4%
            availability: 0.045,       // 4.5%
            contractType: 0.045,       // 4.5%
            listenReasons: 0.027,      // 2.7%
            processPosition: 0.018     // 1.8%
        };

        const motivationToCriteria = {
            'remuneration': ['compensation'],
            'perspectives_evolution': ['semantic', 'companySize', 'industry'],
            'flexibilite': ['workEnvironment', 'contractType'],
            'localisation': ['location'],
            'autre': ['motivation']
        };

        let selectedMotivations = [];

        // === GESTION DES MOTIVATIONS ===
        
        document.addEventListener('DOMContentLoaded', function() {
            setupMotivationSelector();
        });

        function setupMotivationSelector() {
            const items = document.querySelectorAll('.motivation-item');
            items.forEach(item => {
                item.addEventListener('click', function() {
                    const motivation = this.dataset.motivation;
                    toggleMotivation(motivation, this);
                });
            });
        }

        function toggleMotivation(motivation, element) {
            const index = selectedMotivations.indexOf(motivation);
            
            if (index === -1 && selectedMotivations.length < 3) {
                selectedMotivations.push(motivation);
                element.classList.add('selected');
            } else if (index !== -1) {
                selectedMotivations.splice(index, 1);
                element.classList.remove('selected');
            }
            
            updateMotivationDisplay();
        }

        function updateMotivationDisplay() {
            const display = document.getElementById('selectedMotivations');
            if (selectedMotivations.length === 0) {
                display.textContent = 'Aucune';
            } else {
                display.textContent = selectedMotivations.map((m, i) => `${i + 1}. ${getMotivationLabel(m)}`).join(', ');
            }
        }

        function getMotivationLabel(motivation) {
            const labels = {
                'remuneration': 'R√©mun√©ration',
                'localisation': 'Localisation', 
                'flexibilite': 'Flexibilit√©',
                'perspectives_evolution': 'Perspectives √©volution',
                'autre': 'Autre'
            };
            return labels[motivation] || motivation;
        }

        // === CALCUL POND√âRATION DYNAMIQUE ===
        
        function calculateDynamicWeights(motivations) {
            const adjustedWeights = { ...baseWeights };
            const appliedAdjustments = [];
            let totalBoostApplied = 0;

            // Application des boosts
            motivations.slice(0, 3).forEach((motivation, index) => {
                const boost = [0.08, 0.05, 0.03][index]; // +8%, +5%, +3%
                const affectedCriteria = motivationToCriteria[motivation] || [];

                if (affectedCriteria.length === 0) return;

                const boostPerCriterion = boost / affectedCriteria.length;

                affectedCriteria.forEach(criterion => {
                    if (adjustedWeights[criterion] !== undefined) {
                        const oldWeight = adjustedWeights[criterion];
                        adjustedWeights[criterion] += boostPerCriterion;
                        
                        adjustedWeights[criterion] = Math.min(adjustedWeights[criterion], 0.35);

                        const actualBoost = adjustedWeights[criterion] - oldWeight;
                        totalBoostApplied += actualBoost;

                        appliedAdjustments.push({
                            motivation,
                            criterion,
                            rank: index + 1,
                            boost: actualBoost,
                            oldWeight: oldWeight,
                            newWeight: adjustedWeights[criterion],
                            percentage_change: Math.round((actualBoost / oldWeight) * 100)
                        });
                    }
                });
            });

            // Redistribution pour normaliser √† 100%
            const normalizedWeights = redistributeWeights(adjustedWeights, totalBoostApplied);

            return {
                weights: normalizedWeights,
                adjustments: appliedAdjustments,
                totalAdjustment: totalBoostApplied,
                isAdjusted: appliedAdjustments.length > 0
            };
        }

        function redistributeWeights(adjustedWeights, totalBoostApplied) {
            if (totalBoostApplied === 0) return adjustedWeights;

            const totalCurrentWeight = Object.values(adjustedWeights).reduce((sum, weight) => sum + weight, 0);
            const excessWeight = totalCurrentWeight - 1.0;

            if (Math.abs(excessWeight) < 0.001) return adjustedWeights;

            // Crit√®res boost√©s
            const boostedCriteria = new Set();
            Object.keys(motivationToCriteria).forEach(motivation => {
                motivationToCriteria[motivation].forEach(criterion => {
                    boostedCriteria.add(criterion);
                });
            });

            // R√©duction sur crit√®res non boost√©s
            const nonBoostedCriteria = Object.keys(adjustedWeights).filter(criterion => 
                !boostedCriteria.has(criterion)
            );

            if (nonBoostedCriteria.length === 0) {
                const reductionFactor = 1.0 / totalCurrentWeight;
                Object.keys(adjustedWeights).forEach(criterion => {
                    adjustedWeights[criterion] *= reductionFactor;
                });
            } else {
                const totalNonBoostedWeight = nonBoostedCriteria.reduce(
                    (sum, criterion) => sum + adjustedWeights[criterion], 0
                );

                const targetReduction = excessWeight;
                const reductionFactor = Math.max(0, (totalNonBoostedWeight - targetReduction) / totalNonBoostedWeight);

                nonBoostedCriteria.forEach(criterion => {
                    adjustedWeights[criterion] = Math.max(
                        adjustedWeights[criterion] * reductionFactor,
                        0.01
                    );
                });
            }

            // Ajustement fin
            const finalTotal = Object.values(adjustedWeights).reduce((sum, weight) => sum + weight, 0);
            if (Math.abs(finalTotal - 1.0) > 0.001) {
                const maxWeightCriterion = Object.keys(adjustedWeights).reduce((max, criterion) => 
                    adjustedWeights[criterion] > adjustedWeights[max] ? criterion : max
                );
                adjustedWeights[maxWeightCriterion] += (1.0 - finalTotal);
            }

            return adjustedWeights;
        }

        // === TESTS ET AFFICHAGE ===
        
        function testDynamicWeighting() {
            if (selectedMotivations.length === 0) {
                alert('Veuillez s√©lectionner au moins une motivation');
                return;
            }

            console.log('üß™ Test pond√©ration dynamique avec:', selectedMotivations);

            const result = calculateDynamicWeights(selectedMotivations);
            displayResults(result);
        }

        function displayResults(result) {
            const resultsDiv = document.getElementById('results');
            const contentDiv = document.getElementById('resultsContent');
            
            let html = '<div class="score-display">';
            html += `<div style="color: ${result.isAdjusted ? '#22c55e' : '#f59e0b'};">`;
            html += `${result.isAdjusted ? '‚úÖ POND√âRATION APPLIQU√âE' : '‚ö†Ô∏è AUCUN AJUSTEMENT'}`;
            html += '</div>';
            html += `<div style="font-size: 0.6em; margin-top: 10px;">`;
            html += `${result.adjustments.length} ajustements ‚Ä¢ ${Math.round(result.totalAdjustment * 100)}% boost total`;
            html += '</div>';
            html += '</div>';

            if (result.adjustments.length > 0) {
                html += '<h3>üìà Ajustements Appliqu√©s</h3>';
                html += '<div class="criteria-grid">';
                
                result.adjustments.forEach(adj => {
                    html += `<div class="criteria-item">`;
                    html += `<strong>${getCriterionName(adj.criterion)}</strong><br>`;
                    html += `Motivation: ${getMotivationLabel(adj.motivation)} (#${adj.rank})<br>`;
                    html += `${Math.round(adj.oldWeight * 100)}% ‚Üí ${Math.round(adj.newWeight * 100)}% `;
                    html += `<span style="color: #22c55e;">(+${adj.percentage_change}%)</span>`;
                    html += '</div>';
                });
                
                html += '</div>';
            }

            // V√©rification normalisation
            const total = Object.values(result.weights).reduce((sum, w) => sum + w, 0);
            const normalizedPercent = Math.round(total * 100);
            
            html += `<div class="result">`;
            html += `<strong>üéØ Validation Normalisation :</strong> `;
            html += `<span style="color: ${Math.abs(total - 1.0) < 0.001 ? '#22c55e' : '#ef4444'};">`;
            html += `${normalizedPercent}% (${Math.abs(total - 1.0) < 0.001 ? 'Parfait' : 'Erreur'})`;
            html += '</span>';
            html += '</div>';

            contentDiv.innerHTML = html;
            resultsDiv.classList.remove('hidden');
        }

        function showComparison() {
            if (selectedMotivations.length === 0) {
                alert('Veuillez d\'abord s√©lectionner des motivations');
                return;
            }

            const result = calculateDynamicWeights(selectedMotivations);
            
            let html = '<div><h3>‚öñÔ∏è Poids Originaux</h3>';
            html += generateWeightsTable(baseWeights);
            html += '</div>';
            
            html += '<div><h3>üéØ Poids Ajust√©s</h3>';
            html += generateWeightsTable(result.weights, result.adjustments);
            html += '</div>';

            document.getElementById('comparisonContent').innerHTML = html;
            document.getElementById('comparison').classList.remove('hidden');
        }

        function generateWeightsTable(weights, adjustments = []) {
            const adjustedCriteria = new Set(adjustments.map(adj => adj.criterion));
            
            let html = '<div class="criteria-grid">';
            
            Object.entries(weights).forEach(([criterion, weight]) => {
                const isAdjusted = adjustedCriteria.has(criterion);
                const color = isAdjusted ? '#22c55e' : '#6b7280';
                
                html += `<div class="criteria-item" style="border-left-color: ${color};">`;
                html += `<strong style="color: ${color};">${getCriterionName(criterion)}</strong><br>`;
                html += `<span style="font-size: 1.2em; color: ${color};">${Math.round(weight * 100)}%</span>`;
                if (isAdjusted) {
                    html += ` <span style="color: #22c55e;">üìà</span>`;
                }
                html += '</div>';
            });
            
            html += '</div>';
            return html;
        }

        function getCriterionName(criterion) {
            const names = {
                semantic: 'S√©mantique',
                compensation: 'R√©mun√©ration',
                location: 'G√©olocalisation',
                motivation: 'Motivations',
                companySize: 'Taille Entreprise',
                workEnvironment: 'Environnement',
                industry: 'Secteur',
                availability: 'Disponibilit√©',
                contractType: 'Type Contrat',
                listenReasons: 'Anti-patterns',
                processPosition: 'Processus'
            };
            return names[criterion] || criterion;
        }

        function runAllTests() {
            console.log('üî¨ Lancement tests complets...');
            
            const testCases = [
                { name: 'R√©mun√©ration seule', motivations: ['remuneration'] },
                { name: 'Localisation seule', motivations: ['localisation'] },
                { name: 'Flexibilit√© seule', motivations: ['flexibilite'] },
                { name: '√âvolution seule', motivations: ['perspectives_evolution'] },
                { name: 'Mix complet', motivations: ['remuneration', 'flexibilite', 'localisation'] },
                { name: 'Aucune motivation', motivations: [] }
            ];

            let html = '<h3>üß™ R√©sultats Tests Complets</h3>';
            
            testCases.forEach(testCase => {
                const result = calculateDynamicWeights(testCase.motivations);
                const total = Object.values(result.weights).reduce((sum, w) => sum + w, 0);
                const isValid = Math.abs(total - 1.0) < 0.001;
                
                html += `<div class="result">`;
                html += `<strong>${testCase.name}</strong><br>`;
                html += `Ajustements: ${result.adjustments.length} ‚Ä¢ `;
                html += `Total: ${Math.round(total * 100)}% `;
                html += `<span style="color: ${isValid ? '#22c55e' : '#ef4444'};">${isValid ? '‚úÖ' : '‚ùå'}</span>`;
                html += '</div>';
            });

            document.getElementById('resultsContent').innerHTML = html;
            document.getElementById('results').classList.remove('hidden');
        }

        // Affichage √©tat initial
        console.log('üéØ NEXTEN V2.0 - Version all√©g√©e pond√©ration dynamique charg√©e');
        console.log('üìä Poids de base:', baseWeights);
        console.log('üó∫Ô∏è Mapping motivations:', motivationToCriteria);
    </script>
</body>
</html>