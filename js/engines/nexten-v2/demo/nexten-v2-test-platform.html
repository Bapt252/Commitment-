<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NEXTEN V2.0 - Plateforme de Test R√©el</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }
        
        .container {
            max-width: 1800px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.98);
            border-radius: 20px;
            backdrop-filter: blur(10px);
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
            overflow: hidden;
        }
        
        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }
        
        .header h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            font-weight: 700;
        }
        
        .test-banner {
            background: linear-gradient(135deg, #10b981 0%, #059669 100%);
            color: white;
            padding: 15px;
            text-align: center;
            font-weight: 600;
            border-bottom: 3px solid #047857;
        }
        
        .main-grid {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 25px;
            padding: 30px;
        }
        
        .test-section {
            background: #f8f9ff;
            border-radius: 15px;
            padding: 25px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.05);
            border: 2px solid #e5e7eb;
        }
        
        .test-section h2 {
            margin-bottom: 20px;
            color: #374151;
            border-bottom: 3px solid #667eea;
            padding-bottom: 10px;
        }
        
        .upload-zone {
            border: 3px dashed #d1d5db;
            border-radius: 12px;
            padding: 30px;
            text-align: center;
            margin-bottom: 20px;
            transition: all 0.3s ease;
            cursor: pointer;
        }
        
        .upload-zone:hover {
            border-color: #667eea;
            background: #f0f4ff;
        }
        
        .upload-zone.active {
            border-color: #22c55e;
            background: #dcfce7;
        }
        
        .upload-icon {
            font-size: 3rem;
            margin-bottom: 10px;
            opacity: 0.6;
        }
        
        .btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 12px 25px;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            width: 100%;
            margin-bottom: 10px;
            transition: transform 0.2s;
        }
        
        .btn:hover {
            transform: translateY(-2px);
        }
        
        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }
        
        .btn-success {
            background: linear-gradient(135deg, #22c55e 0%, #16a34a 100%);
        }
        
        .btn-warning {
            background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%);
        }
        
        .form-group {
            margin-bottom: 15px;
        }
        
        .form-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: 600;
            color: #555;
            font-size: 13px;
        }
        
        .form-group input,
        .form-group select,
        .form-group textarea {
            width: 100%;
            padding: 10px;
            border: 2px solid #e1e5e9;
            border-radius: 6px;
            font-size: 13px;
        }
        
        .parsed-data {
            background: #f3f4f6;
            border-radius: 8px;
            padding: 15px;
            margin-top: 15px;
            max-height: 200px;
            overflow-y: auto;
            font-family: 'Monaco', 'Consolas', monospace;
            font-size: 11px;
        }
        
        .results-section {
            grid-column: 1 / -1;
            margin-top: 20px;
        }
        
        .results-grid {
            display: grid;
            grid-template-columns: 1fr 2fr;
            gap: 25px;
            margin-top: 20px;
        }
        
        .score-card {
            background: white;
            border-radius: 15px;
            padding: 25px;
            text-align: center;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.05);
            border: 3px solid #e5e7eb;
        }
        
        .score-value {
            font-size: 4rem;
            font-weight: 700;
            margin-bottom: 10px;
        }
        
        .score-excellent { color: #22c55e; border-color: #22c55e; }
        .score-good { color: #3b82f6; border-color: #3b82f6; }
        .score-average { color: #f59e0b; border-color: #f59e0b; }
        .score-poor { color: #ef4444; border-color: #ef4444; }
        
        .criteria-breakdown {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
        }
        
        .criteria-item {
            background: white;
            border-radius: 10px;
            padding: 15px;
            border-left: 4px solid #667eea;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.05);
        }
        
        .criteria-score {
            font-size: 1.5rem;
            font-weight: 700;
            margin-bottom: 5px;
        }
        
        .criteria-name {
            font-size: 0.9rem;
            color: #666;
            margin-bottom: 5px;
        }
        
        .criteria-details {
            font-size: 0.8rem;
            color: #888;
        }
        
        .coherence-analysis {
            background: #f8f9ff;
            border-radius: 12px;
            padding: 20px;
            margin-top: 20px;
            border: 2px solid #e5e7eb;
        }
        
        .coherence-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 0;
            border-bottom: 1px solid #e5e7eb;
        }
        
        .coherence-item:last-child {
            border-bottom: none;
        }
        
        .status-indicator {
            padding: 4px 8px;
            border-radius: 12px;
            font-size: 11px;
            font-weight: 600;
        }
        
        .status-success {
            background: #dcfce7;
            color: #166534;
        }
        
        .status-warning {
            background: #fef3c7;
            color: #92400e;
        }
        
        .status-error {
            background: #fee2e2;
            color: #991b1b;
        }
        
        .hidden { display: none; }
        
        .processing {
            text-align: center;
            padding: 20px;
            color: #667eea;
        }
        
        .spinner {
            border: 3px solid #f3f4f6;
            border-top: 3px solid #667eea;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            animation: spin 1s linear infinite;
            margin: 0 auto 10px;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .quick-start {
            background: #fffbeb;
            border: 2px solid #f59e0b;
            border-radius: 12px;
            padding: 20px;
            margin: 20px;
            text-align: center;
        }

        .quick-start h3 {
            color: #92400e;
            margin-bottom: 15px;
        }

        .fix-banner {
            background: linear-gradient(135deg, #16a34a 0%, #15803d 100%);
            color: white;
            padding: 10px;
            text-align: center;
            font-weight: 600;
            border-bottom: 2px solid #14532d;
            font-size: 13px;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="fix-banner">
            üî• CORRECTIF FINAL: Pond√©rations Exactes 100% + Score Plafonn√© + Logique Salariale RH
        </div>
        
        <div class="test-banner">
            üß™ PLATEFORME DE TEST R√âEL NEXTEN V2.0 - Repository: Bapt1505/Commitment-
        </div>
        
        <div class="header">
            <h1>üß™ NEXTEN V2.0 - Test R√©el</h1>
            <div class="subtitle">Upload CV + Fiche de poste ‚Üí Auto-remplissage ‚Üí Matching r√©el</div>
        </div>

        <div class="quick-start">
            <h3>üöÄ Test Rapide - Commencez ici !</h3>
            <button class="btn btn-warning" onclick="loadTestExample()" style="max-width: 300px; margin: 0 auto;">
                üìù CHARGER EXEMPLE DE TEST
            </button>
            <p style="margin-top: 10px; font-size: 14px; color: #666;">
                Charge automatiquement un profil candidat + poste pour tester imm√©diatement
            </p>
        </div>
        
        <div class="main-grid">
            <!-- Section 1: Upload CV -->
            <div class="test-section">
                <h2>üìÑ 1. Upload CV Candidat</h2>
                
                <div class="upload-zone" id="cvUploadZone" onclick="document.getElementById('cvFile').click()">
                    <div class="upload-icon">üìÑ</div>
                    <div><strong>Glissez votre CV ici</strong></div>
                    <div>ou cliquez pour s√©lectionner</div>
                    <div style="font-size: 11px; margin-top: 10px;">PDF, DOCX, TXT</div>
                </div>
                
                <input type="file" id="cvFile" accept=".pdf,.docx,.txt" style="display: none;">
                
                <div class="form-group">
                    <label>Ou saisie manuelle rapide :</label>
                    <textarea id="cvText" rows="4" placeholder="Nom, exp√©rience, comp√©tences, secteur, salaire souhait√©..."></textarea>
                </div>
                
                <button class="btn" onclick="parseCVData()">üîç Parser CV</button>
                
                <div id="cvParsedData" class="parsed-data hidden">
                    <strong>Donn√©es extraites :</strong>
                    <pre id="cvDataPreview"></pre>
                </div>
                
                <div id="cvStatus" class="hidden">
                    <div class="status-indicator status-success">‚úÖ CV analys√©</div>
                </div>
            </div>
            
            <!-- Section 2: Upload Fiche de Poste -->
            <div class="test-section">
                <h2>üíº 2. Fiche de Poste</h2>
                
                <div class="upload-zone" id="jobUploadZone" onclick="document.getElementById('jobFile').click()">
                    <div class="upload-icon">üíº</div>
                    <div><strong>Glissez la fiche de poste</strong></div>
                    <div>ou cliquez pour s√©lectionner</div>
                    <div style="font-size: 11px; margin-top: 10px;">PDF, DOCX, TXT</div>
                </div>
                
                <input type="file" id="jobFile" accept=".pdf,.docx,.txt" style="display: none;">
                
                <div class="form-group">
                    <label>Ou saisie manuelle :</label>
                    <textarea id="jobText" rows="4" placeholder="Titre poste, missions, comp√©tences, salaire, secteur, lieu..."></textarea>
                </div>
                
                <button class="btn" onclick="parseJobData()">üîç Parser Fiche</button>
                
                <div id="jobParsedData" class="parsed-data hidden">
                    <strong>Donn√©es extraites :</strong>
                    <pre id="jobDataPreview"></pre>
                </div>
                
                <div id="jobStatus" class="hidden">
                    <div class="status-indicator status-success">‚úÖ Fiche analys√©e</div>
                </div>
            </div>
            
            <!-- Section 3: Auto-remplissage & Test -->
            <div class="test-section">
                <h2>‚öôÔ∏è 3. Test NEXTEN V2.0</h2>
                
                <button class="btn" onclick="autoFillQuestionnaires()" id="autoFillBtn" disabled>
                    üìã Auto-remplir Questionnaires
                </button>
                
                <div id="questionnaireStatus" class="hidden">
                    <div class="status-indicator status-success">‚úÖ Questionnaires remplis</div>
                </div>
                
                <div class="form-group">
                    <label>Connexion NEXTEN V2.0 :</label>
                    <select id="nextenConnection">
                        <option value="direct">Connexion directe (modules GitHub)</option>
                        <option value="simulation">Mode simulation avanc√©e</option>
                    </select>
                </div>
                
                <button class="btn btn-success" onclick="runRealMatching()" id="matchingBtn" disabled>
                    üéØ LANCER MATCHING R√âEL
                </button>
                
                <div id="processingStatus" class="processing hidden">
                    <div class="spinner"></div>
                    <div>Calcul matching en cours...</div>
                </div>
            </div>
        </div>
        
        <!-- Section R√©sultats -->
        <div class="test-section results-section hidden" id="resultsSection">
            <h2>üìä R√©sultats du Matching R√©el</h2>
            
            <div class="results-grid">
                <!-- Score Principal -->
                <div class="score-card" id="mainScoreCard">
                    <div class="score-value" id="finalMatchScore">--%</div>
                    <div id="matchQuality">Calcul en cours...</div>
                    <div style="margin-top: 10px; font-size: 0.9rem;">
                        <div>‚ö° Temps: <span id="calcTime">--ms</span></div>
                        <div>üîß Mode: <span id="calcMode">--</span></div>
                        <div>üìè Crit√®res: <span id="criteriaCount">--/11</span></div>
                    </div>
                </div>
                
                <!-- Breakdown Crit√®res -->
                <div>
                    <h3 style="margin-bottom: 15px;">D√©tail des 11 Crit√®res NEXTEN V2.0</h3>
                    <div class="criteria-breakdown" id="criteriaBreakdown">
                        <!-- Crit√®res inject√©s ici -->
                    </div>
                </div>
            </div>
            
            <!-- Analyse de Coh√©rence -->
            <div class="coherence-analysis">
                <h3 style="margin-bottom: 15px;">üîç Analyse de Coh√©rence</h3>
                <div id="coherenceResults">
                    <!-- Analyses inject√©es ici -->
                </div>
            </div>
        </div>
    </div>
    
    <script>
        // Variables globales
        let cvData = null;
        let jobData = null;
        let companyData = null;
        let matchingResult = null;
        
        // Configuration pour le nouveau repository
        const MODULE_BASE_URL = 'https://raw.githack.com/Bapt1505/Commitment-/feature/nexten-v2-11-criteria/js/engines/nexten-v2';
        
        // Donn√©es d'exemple pour tests rapides
        const testExamples = {
            cv: {
                nom: "Sophie Martin",
                email: "sophie.martin@email.com",
                pretentions_salariales: "95-110k‚Ç¨",
                experience_annees: 8,
                poste_actuel: "Senior Marketing Manager",
                secteur_actuel: "luxe",
                competences: ["Marketing Digital", "Brand Management", "Luxe", "E-commerce", "Analytics"],
                experiences: [
                    { entreprise: "LVMH", poste: "Marketing Manager", secteur: "luxe", duree: "3 ans" },
                    { entreprise: "L'Or√©al", poste: "Chef de Produit", secteur: "cosmetique", duree: "2 ans" }
                ],
                formations: ["Master Marketing HEC", "√âcole de Commerce"],
                motivations: ["evolution_carriere", "innovation_creativite", "remuneration"],
                taille_entreprise_preference: "groupe",
                secteurs_cibles: ["luxe", "mode", "cosmetique"],
                disponibilite: "2_mois",
                coordonnees: {
                    ville: "Paris",
                    adresse: "15 Avenue Montaigne, 75008 Paris"
                }
            },
            job: {
                titre: "Directeur Marketing Digital - Marque de Luxe",
                entreprise: "Maison Prestige",
                secteur: "luxe",
                missions: [
                    "D√©velopper la strat√©gie marketing digital",
                    "Manager une √©quipe de 12 personnes",
                    "Lancer de nouveaux produits internationaux",
                    "G√©rer budget 5M‚Ç¨"
                ],
                competences_requises: ["Marketing Digital", "Luxe", "Management", "International", "Budget Management"],
                fourchette_salariale: "100-120k‚Ç¨",
                type_contrat: "cdi",
                mode_travail: "hybrid_3_2",
                urgence_recrutement: "normal",
                coordonnees: {
                    ville: "Paris",
                    adresse: "Place Vend√¥me, 75001 Paris"
                }
            },
            company: {
                nom: "Maison Prestige",
                secteur: "luxe",
                effectif: 1200,
                localisation: "Paris",
                description: "Maison de luxe fran√ßaise, leader mondial"
            }
        };
        
        // Initialisation
        setupDragAndDrop();
        
        function setupDragAndDrop() {
            // CV Upload Zone
            const cvZone = document.getElementById('cvUploadZone');
            const jobZone = document.getElementById('jobUploadZone');
            
            [cvZone, jobZone].forEach(zone => {
                zone.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    zone.classList.add('active');
                });
                
                zone.addEventListener('dragleave', (e) => {
                    e.preventDefault();
                    zone.classList.remove('active');
                });
                
                zone.addEventListener('drop', (e) => {
                    e.preventDefault();
                    zone.classList.remove('active');
                    
                    const files = e.dataTransfer.files;
                    if (files.length > 0) {
                        if (zone.id === 'cvUploadZone') {
                            handleCVFile(files[0]);
                        } else {
                            handleJobFile(files[0]);
                        }
                    }
                });
            });
            
            // File input handlers
            document.getElementById('cvFile').addEventListener('change', (e) => {
                if (e.target.files.length > 0) {
                    handleCVFile(e.target.files[0]);
                }
            });
            
            document.getElementById('jobFile').addEventListener('change', (e) => {
                if (e.target.files.length > 0) {
                    handleJobFile(e.target.files[0]);
                }
            });
        }
        
        async function handleCVFile(file) {
            console.log('Traitement CV:', file.name);
            
            // Simulation de parsing de fichier
            const text = await readFileAsText(file);
            document.getElementById('cvText').value = text.substring(0, 500) + '...';
            
            // Auto-parse
            parseCVData();
        }
        
        async function handleJobFile(file) {
            console.log('Traitement fiche de poste:', file.name);
            
            // Simulation de parsing de fichier
            const text = await readFileAsText(file);
            document.getElementById('jobText').value = text.substring(0, 500) + '...';
            
            // Auto-parse
            parseJobData();
        }
        
        function readFileAsText(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = (e) => resolve(e.target.result);
                reader.onerror = reject;
                reader.readAsText(file);
            });
        }
        
        function parseCVData() {
            const cvText = document.getElementById('cvText').value;
            
            if (!cvText.trim()) {
                alert('Veuillez saisir ou uploader un CV');
                return;
            }
            
            // Simulation d'extraction intelligente de donn√©es
            cvData = extractCVData(cvText);
            
            // Affichage des donn√©es extraites
            document.getElementById('cvDataPreview').textContent = JSON.stringify(cvData, null, 2);
            document.getElementById('cvParsedData').classList.remove('hidden');
            document.getElementById('cvStatus').classList.remove('hidden');
            
            // Activation du bouton suivant
            checkReadyForAutoFill();
            
            console.log('CV pars√©:', cvData);
        }
        
        function parseJobData() {
            const jobText = document.getElementById('jobText').value;
            
            if (!jobText.trim()) {
                alert('Veuillez saisir ou uploader une fiche de poste');
                return;
            }
            
            // Simulation d'extraction intelligente de donn√©es
            const parsed = extractJobData(jobText);
            jobData = parsed.job;
            companyData = parsed.company;
            
            // Affichage des donn√©es extraites
            const combinedData = { job: jobData, company: companyData };
            document.getElementById('jobDataPreview').textContent = JSON.stringify(combinedData, null, 2);
            document.getElementById('jobParsedData').classList.remove('hidden');
            document.getElementById('jobStatus').classList.remove('hidden');
            
            // Activation du bouton suivant
            checkReadyForAutoFill();
            
            console.log('Fiche pars√©e:', { job: jobData, company: companyData });
        }
        
        function extractCVData(text) {
            // Simulation d'IA de parsing CV
            const lowerText = text.toLowerCase();
            
            // Extraction des patterns courants
            const salaryMatch = text.match(/(\d+)[-\s]*(\d+)?\s*k?‚Ç¨?/i);
            const emailMatch = text.match(/[\w.-]+@[\w.-]+\.\w+/);
            const phoneMatch = text.match(/(?:\+33|0)[1-9](?:[.\-\s]?\d{2}){4}/);
            
            // D√©tection de secteur
            let secteur = 'tech';
            if (lowerText.includes('luxe') || lowerText.includes('lvmh') || lowerText.includes('chanel')) secteur = 'luxe';
            if (lowerText.includes('banque') || lowerText.includes('finance')) secteur = 'finance';
            if (lowerText.includes('mode') || lowerText.includes('fashion')) secteur = 'mode';
            
            // Extraction de comp√©tences
            const competences = [];
            const skillPatterns = [
                'marketing', 'management', 'digital', 'analytics', 'projet', 'equipe',
                'javascript', 'python', 'react', 'node', 'sql', 'excel',
                'luxe', 'retail', 'e-commerce', 'brand', 'communication'
            ];
            
            skillPatterns.forEach(skill => {
                if (lowerText.includes(skill)) {
                    competences.push(skill.charAt(0).toUpperCase() + skill.slice(1));
                }
            });
            
            return {
                nom: extractName(text) || "Candidat Test",
                email: emailMatch ? emailMatch[0] : "candidat@test.com",
                telephone: phoneMatch ? phoneMatch[0] : "01 23 45 67 89",
                pretentions_salariales: salaryMatch ? `${salaryMatch[1]}-${parseInt(salaryMatch[1]) + 15}k‚Ç¨` : "50-65k‚Ç¨",
                secteur_actuel: secteur,
                competences: competences.length > 0 ? competences : ["Marketing", "Management"],
                experiences: extractExperiences(text),
                motivations: ["evolution_carriere", "remuneration", "apprentissage"],
                taille_entreprise_preference: detectCompanySize(text),
                disponibilite: "2_mois",
                secteurs_cibles: [secteur],
                coordonnees: {
                    ville: "Paris",
                    adresse: extractAddress(text) || "Paris, France"
                }
            };
        }
        
        function extractJobData(text) {
            const lowerText = text.toLowerCase();
            
            // Extraction salaire
            const salaryMatch = text.match(/(\d+)[-\s]*(\d+)?\s*k?‚Ç¨?/i);
            
            // D√©tection secteur
            let secteur = 'tech';
            if (lowerText.includes('luxe')) secteur = 'luxe';
            if (lowerText.includes('finance') || lowerText.includes('banque')) secteur = 'finance';
            if (lowerText.includes('mode')) secteur = 'mode';
            
            // Extraction titre
            const lines = text.split('\n').filter(line => line.trim());
            const titre = lines[0] || "Poste √† d√©finir";
            
            return {
                job: {
                    id: 'parsed_job_' + Date.now(),
                    titre: titre,
                    fourchette_salariale: salaryMatch ? `${salaryMatch[1]}-${parseInt(salaryMatch[1]) + 10}k‚Ç¨` : "60-75k‚Ç¨",
                    secteur: secteur,
                    competences_requises: extractRequiredSkills(text),
                    type_contrat: "cdi",
                    mode_travail: detectWorkMode(text),
                    urgence_recrutement: "normal",
                    coordonnees: {
                        ville: "Paris",
                        adresse: extractAddress(text) || "Paris, France"
                    }
                },
                company: {
                    nom: extractCompanyName(text) || "Entreprise Test",
                    secteur: secteur,
                    effectif: estimateCompanySize(text),
                    localisation: "Paris"
                }
            };
        }
        
        // Fonctions utilitaires d'extraction
        function extractName(text) {
            const lines = text.split('\n').filter(line => line.trim());
            const firstLine = lines[0];
            if (firstLine && firstLine.length < 50 && !firstLine.includes('@')) {
                return firstLine.trim();
            }
            return null;
        }
        
        function extractExperiences(text) {
            return [
                { entreprise: "Entreprise A", poste: "Poste pr√©c√©dent", duree: "2 ans" }
            ];
        }
        
        function extractRequiredSkills(text) {
            const skills = [];
            const skillPatterns = [
                'marketing', 'management', 'digital', 'analytics', 'javascript', 'python',
                'excel', 'powerpoint', 'anglais', 'projet', '√©quipe'
            ];
            
            const lowerText = text.toLowerCase();
            skillPatterns.forEach(skill => {
                if (lowerText.includes(skill)) {
                    skills.push(skill.charAt(0).toUpperCase() + skill.slice(1));
                }
            });
            
            return skills.length > 0 ? skills : ["Comp√©tences requises"];
        }
        
        function extractCompanyName(text) {
            const lines = text.split('\n').filter(line => line.trim());
            
            for (let line of lines) {
                if (line.toLowerCase().includes('entreprise') || 
                    line.toLowerCase().includes('soci√©t√©') ||
                    line.toLowerCase().includes('group')) {
                    return line.trim();
                }
            }
            return null;
        }
        
        function extractAddress(text) {
            const addressMatch = text.match(/\d+.*(?:rue|avenue|boulevard|place).*(?:\d{5}|paris|lyon|marseille)/i);
            return addressMatch ? addressMatch[0] : null;
        }
        
        function detectCompanySize(text) {
            const lowerText = text.toLowerCase();
            if (lowerText.includes('startup') || lowerText.includes('jeune entreprise')) return 'startup';
            if (lowerText.includes('pme') || lowerText.includes('petite entreprise')) return 'pme';
            if (lowerText.includes('grand groupe') || lowerText.includes('multinationale')) return 'groupe';
            return 'eti';
        }
        
        function detectWorkMode(text) {
            const lowerText = text.toLowerCase();
            if (lowerText.includes('t√©l√©travail') || lowerText.includes('remote')) return 'hybrid_3_2';
            if (lowerText.includes('pr√©sentiel')) return 'on_site_100';
            return 'hybrid_3_2';
        }
        
        function estimateCompanySize(text) {
            const lowerText = text.toLowerCase();
            if (lowerText.includes('startup')) return 50;
            if (lowerText.includes('pme')) return 200;
            if (lowerText.includes('grand groupe')) return 5000;
            return 500;
        }
        
        function checkReadyForAutoFill() {
            const cvReady = cvData !== null;
            const jobReady = jobData !== null && companyData !== null;
            
            document.getElementById('autoFillBtn').disabled = !(cvReady && jobReady);
            
            if (cvReady && jobReady) {
                document.getElementById('autoFillBtn').classList.add('btn-success');
            }
        }
        
        function autoFillQuestionnaires() {
            if (!cvData || !jobData || !companyData) {
                alert('Veuillez d\'abord parser le CV et la fiche de poste');
                return;
            }
            
            console.log('Auto-remplissage des questionnaires...');
            console.log('CV Data:', cvData);
            console.log('Job Data:', jobData);
            console.log('Company Data:', companyData);
            
            // Simulation du mapping automatique
            setTimeout(() => {
                document.getElementById('questionnaireStatus').classList.remove('hidden');
                document.getElementById('matchingBtn').disabled = false;
                document.getElementById('matchingBtn').classList.add('btn-success');
                
                alert('‚úÖ Questionnaires auto-remplis ! Pr√™t pour le matching.');
            }, 1000);
        }
        
        async function runRealMatching() {
            if (!cvData || !jobData || !companyData) {
                alert('Donn√©es manquantes pour le matching');
                return;
            }
            
            // Affichage du processing
            document.getElementById('processingStatus').classList.remove('hidden');
            document.getElementById('resultsSection').classList.remove('hidden');
            
            const nextenConnection = document.getElementById('nextenConnection').value;
            
            try {
                console.log('üöÄ Lancement matching NEXTEN V2.0...');
                console.log('Connexion:', nextenConnection);
                
                const startTime = performance.now();
                
                // Tenter de charger et utiliser le vrai syst√®me NEXTEN V2.0
                let matchingResult;
                if (nextenConnection === 'direct') {
                    matchingResult = await tryRealNEXTENCalculation(cvData, jobData, companyData);
                } else {
                    matchingResult = await simulateNEXTENMatching(cvData, jobData, companyData, 'simulation');
                }
                
                matchingResult.calculationTime = performance.now() - startTime;
                
                console.log('‚úÖ R√©sultat matching:', matchingResult);
                
                // Affichage des r√©sultats
                displayMatchingResults(matchingResult);
                
                // Analyse de coh√©rence
                analyzeCoherence(cvData, jobData, matchingResult);
                
            } catch (error) {
                console.error('‚ùå Erreur matching:', error);
                alert('Erreur lors du matching: ' + error.message);
            } finally {
                document.getElementById('processingStatus').classList.add('hidden');
            }
        }
        
        async function tryRealNEXTENCalculation(candidateData, jobData, companyData) {
            try {
                // Tentative de chargement des vrais modules NEXTEN V2.0
                console.log('üî• Tentative connexion modules NEXTEN V2.0 r√©els...');
                
                // Chargement dynamique de l'orchestrateur
                const orchestratorUrl = MODULE_BASE_URL + '/core/nexten-v2-unified-system-updated.js';
                
                await loadScript(orchestratorUrl);
                
                // V√©rification disponibilit√©
                if (typeof window.NextenV2UnifiedSystem !== 'undefined') {
                    const nextenSystem = new window.NextenV2UnifiedSystem();
                    
                    // Test des m√©thodes disponibles
                    if (typeof nextenSystem.calculateV2MatchingScore === 'function') {
                        console.log('‚úÖ Utilisation syst√®me NEXTEN V2.0 R√âEL');
                        const result = await nextenSystem.calculateV2MatchingScore(candidateData, jobData, companyData);
                        result.version = '2.0-REAL';
                        result.matchingMode = 'real_nexten_v2';
                        return result;
                    }
                }
                
                throw new Error('Modules NEXTEN V2.0 non disponibles');
                
            } catch (error) {
                console.warn('‚ö†Ô∏è Fallback vers simulation:', error.message);
                const result = await simulateNEXTENMatching(candidateData, jobData, companyData, 'simulation');
                result.version = '2.0-SIMULATION (Fallback)';
                return result;
            }
        }
        
        function loadScript(url) {
            return new Promise((resolve, reject) => {
                const script = document.createElement('script');
                script.src = url;
                script.onload = resolve;
                script.onerror = () => reject(new Error(`Failed to load ${url}`));
                document.head.appendChild(script);
            });
        }
        
        async function simulateNEXTENMatching(candidateData, jobData, companyData, mode) {
            // Simulation avanc√©e du syst√®me NEXTEN V2.0
            
            const criteriaResults = {
                semantic: calculateSemanticMatch(candidateData, jobData),
                location: calculateLocationMatch(candidateData, jobData),
                compensation: calculateCompensationMatch(candidateData, jobData),
                motivation: calculateMotivationMatch(candidateData, jobData),
                companySize: calculateCompanySizeMatch(candidateData, companyData),
                workEnvironment: calculateWorkEnvironmentMatch(candidateData, jobData),
                industry: calculateIndustryMatch(candidateData, jobData),
                availability: calculateAvailabilityMatch(candidateData, jobData),
                contractType: calculateContractMatch(candidateData, jobData),
                listenReasons: calculateAntiPatternsMatch(candidateData),
                processPosition: calculateProcessPositionMatch(candidateData, jobData)
            };
            
            // üî• POND√âRATIONS CORRIG√âES - TOTAL EXACTEMENT 100%
            const weights = {
                semantic: 0.205,       // 20.5% (‚Üò √©tait 23%)
                location: 0.161,       // 16.1% (‚Üò √©tait 18%)
                compensation: 0.196,   // 19.6% (‚Üò √©tait 22%, reste prioritaire ‚≠ê)
                motivation: 0.107,     // 10.7% (‚Üò √©tait 12%)
                companySize: 0.071,    // 7.1% (‚Üò √©tait 8%)
                workEnvironment: 0.071, // 7.1% (‚Üò √©tait 8%)
                industry: 0.054,       // 5.4% (‚Üò √©tait 6%)
                availability: 0.045,   // 4.5% (‚Üò √©tait 5%)
                contractType: 0.045,   // 4.5% (‚Üò √©tait 5%)
                listenReasons: 0.027,  // 2.7% (‚Üò √©tait 3%)
                processPosition: 0.018 // 1.8% (‚Üò √©tait 2%)
            };
            // TOTAL V√âRIFI√â = 100.0% ‚úÖ
            
            let finalScore = 0;
            let criteriaUsed = 0;
            
            Object.keys(criteriaResults).forEach(criterion => {
                if (criteriaResults[criterion].score !== null) {
                    finalScore += criteriaResults[criterion].score * weights[criterion];
                    criteriaUsed++;
                }
            });
            
            // üîí PLAFONNEMENT STRICT √Ä 100% MAXIMUM
            finalScore = Math.min(1.0, finalScore);
            
            const qualityLevel = finalScore >= 0.85 ? 'excellent' : 
                                finalScore >= 0.70 ? 'good' : 
                                finalScore >= 0.55 ? 'average' : 'poor';
            
            return {
                finalScore: finalScore,
                version: mode === 'real' ? '2.0-REAL' : '2.0-SIMULATION',
                qualityLevel: qualityLevel,
                matchingMode: mode === 'real' ? 'real_calculation' : 'advanced_simulation',
                criteriaBreakdown: { criteria: criteriaResults },
                performance: {
                    criteriaUsed: criteriaUsed,
                    precision_estimated: mode === 'real' ? 0.97 : 0.88
                },
                dataUsage: {
                    total_coverage: Math.min(0.95, criteriaUsed / 11)
                }
            };
        }
        
        // Fonctions de calcul des crit√®res (simplifi√©es pour la d√©mo)
        function calculateSemanticMatch(candidate, job) {
            const candidateSkills = candidate.competences || [];
            const requiredSkills = job.competences_requises || [];
            
            let matches = 0;
            candidateSkills.forEach(skill => {
                if (requiredSkills.some(req => req.toLowerCase().includes(skill.toLowerCase()))) {
                    matches++;
                }
            });
            
            const score = Math.min(1, matches / Math.max(requiredSkills.length, 1) + 0.3);
            return {
                score: score,
                percentage: Math.round(score * 100),
                details: `${matches} comp√©tences align√©es`,
                fallback: false
            };
        }
        
        function calculateLocationMatch(candidate, job) {
            const candidateCity = candidate.coordonnees?.ville || 'Paris';
            const jobCity = job.coordonnees?.ville || 'Paris';
            
            const score = candidateCity.toLowerCase() === jobCity.toLowerCase() ? 0.95 : 0.60;
            
            return {
                score: score,
                percentage: Math.round(score * 100),
                details: candidateCity === jobCity ? 'M√™me ville' : 'Villes diff√©rentes',
                fallback: false
            };
        }
        
        // ‚úÖ FONCTION CORRIG√âE - Matching Salarial avec Logique RH
        function calculateCorrectSalaryMatch(candidateRange, jobRange) {
            const candidateMin = candidateRange.min;
            const candidateMax = candidateRange.max;
            const jobMin = jobRange.min;
            const jobMax = jobRange.max;
            
            // Cas 1: Candidat compl√®tement sous budget (EXCELLENT pour l'entreprise)
            if (candidateMax <= jobMin) {
                const savings = jobMin - candidateMax;
                const savingsPercent = (savings / jobMin) * 100;
                return {
                    score: 0.98,
                    details: `Sous budget (√©conomie ${savingsPercent.toFixed(0)}%)`
                };
            }
            
            // Cas 2: Candidat parfaitement dans la fourchette
            if (candidateMin >= jobMin && candidateMax <= jobMax) {
                return {
                    score: 1.0,
                    details: `Alignement parfait dans fourchette`
                };
            }
            
            // Cas 3: Chevauchement partiel
            if (candidateMin <= jobMax && candidateMax >= jobMin) {
                const overlapStart = Math.max(candidateMin, jobMin);
                const overlapEnd = Math.min(candidateMax, jobMax);
                const candidateRange_size = candidateMax - candidateMin;
                const overlapRatio = (overlapEnd - overlapStart) / candidateRange_size;
                
                // Si la majorit√© de la fourchette candidat est dans budget
                if (overlapRatio >= 0.7) {
                    return {
                        score: 0.90,
                        details: `Bon chevauchement (${Math.round(overlapRatio * 100)}%)`
                    };
                } else {
                    return {
                        score: 0.75,
                        details: `Chevauchement partiel (${Math.round(overlapRatio * 100)}%)`
                    };
                }
            }
            
            // Cas 4: Candidat au-dessus du budget (PROBL√âMATIQUE)
            if (candidateMin > jobMax) {
                const excess = candidateMin - jobMax;
                const excessPercent = (excess / jobMax) * 100;
                
                if (excessPercent <= 10) {
                    return {
                        score: 0.65,
                        details: `L√©g√®rement au-dessus (+${excessPercent.toFixed(0)}%, n√©gociable)`
                    };
                } else if (excessPercent <= 20) {
                    return {
                        score: 0.45,
                        details: `Au-dessus budget (+${excessPercent.toFixed(0)}%, difficile)`
                    };
                } else {
                    return {
                        score: 0.25,
                        details: `Tr√®s au-dessus budget (+${excessPercent.toFixed(0)}%, probl√©matique)`
                    };
                }
            }
            
            // Cas 5: Candidat en dessous mais avec chevauchement faible
            return {
                score: 0.80,
                details: `Fourchettes proches`
            };
        }
        
        function calculateCompensationMatch(candidate, job) {
            const candidateSalary = extractSalaryRange(candidate.pretentions_salariales);
            const jobSalary = extractSalaryRange(job.fourchette_salariale);
            
            if (!candidateSalary || !jobSalary) {
                return { score: 0.70, percentage: 70, details: 'Donn√©es incompl√®tes', fallback: true };
            }
            
            // ‚úÖ UTILISATION DE LA NOUVELLE LOGIQUE RH
            const matchResult = calculateCorrectSalaryMatch(candidateSalary, jobSalary);
            
            return {
                score: matchResult.score,
                percentage: Math.round(matchResult.score * 100),
                details: matchResult.details,
                fallback: false
            };
        }
        
        function calculateMotivationMatch(candidate, job) {
            const motivations = candidate.motivations || [];
            let score = 0.70; // Score de base
            
            if (motivations.includes('evolution_carriere') && job.titre.toLowerCase().includes('senior')) {
                score += 0.15;
            }
            if (motivations.includes('remuneration')) {
                score += 0.10;
            }
            if (motivations.includes('innovation_creativite') && job.secteur === 'tech') {
                score += 0.10;
            }
            
            return {
                score: Math.min(1, score),
                percentage: Math.round(Math.min(1, score) * 100),
                details: `${motivations.length} motivations analys√©es`,
                fallback: false
            };
        }
        
        function calculateCompanySizeMatch(candidate, company) {
            const preference = candidate.taille_entreprise_preference;
            const actualSize = company.effectif;
            
            let score = 0.50;
            
            if (preference === 'startup' && actualSize <= 50) score = 0.90;
            else if (preference === 'pme' && actualSize <= 500) score = 0.85;
            else if (preference === 'eti' && actualSize <= 5000) score = 0.85;
            else if (preference === 'groupe' && actualSize > 1000) score = 0.90;
            else score = 0.60; // Mismatch mod√©r√©
            
            return {
                score: score,
                percentage: Math.round(score * 100),
                details: `Pr√©f√©rence: ${preference}, R√©el: ${actualSize} employ√©s`,
                fallback: false
            };
        }
        
        function calculateWorkEnvironmentMatch(candidate, job) {
            const workMode = job.mode_travail || 'hybrid_3_2';
            let score = 0.75; // Score par d√©faut
            
            // Ajustements selon le mode de travail
            if (workMode === 'hybrid_3_2') score = 0.85;
            if (workMode === 'remote_100') score = 0.80;
            if (workMode === 'on_site_100') score = 0.65;
            
            return {
                score: score,
                percentage: Math.round(score * 100),
                details: `Mode: ${workMode}`,
                fallback: false
            };
        }
        
        function calculateIndustryMatch(candidate, job) {
            const candidateSectors = candidate.secteurs_cibles || [candidate.secteur_actuel];
            const jobSector = job.secteur;
            
            const isMatch = candidateSectors.includes(jobSector);
            const score = isMatch ? 0.95 : 0.40;
            
            return {
                score: score,
                percentage: Math.round(score * 100),
                details: isMatch ? 'Secteur cibl√©' : 'Secteur diff√©rent',
                fallback: false
            };
        }
        
        function calculateAvailabilityMatch(candidate, job) {
            const availability = candidate.disponibilite || '2_mois';
            const urgency = job.urgence_recrutement || 'normal';
            
            let score = 0.70;
            
            if (urgency === 'urgent' && availability === 'immediate') score = 0.95;
            else if (urgency === 'normal' && ['1_mois', '2_mois'].includes(availability)) score = 0.85;
            else if (urgency === 'flexible') score = 0.80;
            
            return {
                score: score,
                percentage: Math.round(score * 100),
                details: `Disponibilit√©: ${availability}, Urgence: ${urgency}`,
                fallback: false
            };
        }
        
        function calculateContractMatch(candidate, job) {
            const preferredContract = candidate.type_contrat_souhaite || 'cdi';
            const offeredContract = job.type_contrat || 'cdi';
            
            const score = preferredContract === offeredContract ? 0.95 : 0.60;
            
            return {
                score: score,
                percentage: Math.round(score * 100),
                details: `Souhait√©: ${preferredContract}, Offert: ${offeredContract}`,
                fallback: false
            };
        }
        
        function calculateAntiPatternsMatch(candidate) {
            let score = 0.85; // Score par d√©faut √©lev√©
            
            const experiences = candidate.experiences || [];
            if (experiences.length === 0) score -= 0.10;
            
            return {
                score: score,
                percentage: Math.round(score * 100),
                details: 'Pas de red flags d√©tect√©s',
                fallback: false
            };
        }
        
        function calculateProcessPositionMatch(candidate, job) {
            const score = 0.75; // Score neutre
            
            return {
                score: score,
                percentage: Math.round(score * 100),
                details: 'Timing appropri√©',
                fallback: false
            };
        }
        
        // Fonctions utilitaires
        function extractSalaryRange(salaryString) {
            if (!salaryString) return null;
            
            const matches = salaryString.match(/(\d+)[-\s]*(\d+)?/);
            if (!matches) return null;
            
            const min = parseInt(matches[1]);
            const max = matches[2] ? parseInt(matches[2]) : min + 10;
            
            return { min, max };
        }
        
        function calculateSalaryOverlap(range1, range2) {
            const overlapStart = Math.max(range1.min, range2.min);
            const overlapEnd = Math.min(range1.max, range2.max);
            
            if (overlapStart > overlapEnd) return 0;
            
            const overlapSize = overlapEnd - overlapStart;
            const totalRange = Math.max(range1.max, range2.max) - Math.min(range1.min, range2.min);
            
            return overlapSize / totalRange;
        }
        
        function displayMatchingResults(result) {
            // Score principal avec plafonnement strict
            const scoreElement = document.getElementById('finalMatchScore');
            const scoreValue = Math.min(100, Math.round(result.finalScore * 100)); // üîí PLAFONNEMENT STRICT
            scoreElement.textContent = scoreValue + '%';
            
            // Classe CSS selon le score
            const scoreCard = document.getElementById('mainScoreCard');
            scoreCard.className = 'score-card ' + getScoreClass(result.finalScore);
            
            // Qualit√© du match
            document.getElementById('matchQuality').textContent = getQualityLabel(result.qualityLevel);
            
            // M√©triques
            document.getElementById('calcTime').textContent = Math.round(result.calculationTime) + 'ms';
            document.getElementById('calcMode').textContent = result.version;
            document.getElementById('criteriaCount').textContent = result.performance.criteriaUsed + '/11';
            
            // Breakdown des crit√®res
            displayCriteriaBreakdown(result.criteriaBreakdown.criteria);
        }
        
        function displayCriteriaBreakdown(criteria) {
            const container = document.getElementById('criteriaBreakdown');
            container.innerHTML = '';
            
            // üî• POND√âRATIONS CORRIG√âES DANS L'AFFICHAGE
            const criteriaInfo = {
                semantic: { name: 'Compatibilit√© S√©mantique', icon: 'üß†', weight: '20.5%' },
                location: { name: 'G√©olocalisation', icon: 'üìç', weight: '16.1%' },
                compensation: { name: 'R√©mun√©ration', icon: 'üí∞', weight: '19.6%' }, // ‚≠ê PRIORITAIRE
                motivation: { name: 'Motivations', icon: 'üéØ', weight: '10.7%' },
                companySize: { name: 'Taille Entreprise', icon: 'üè¢', weight: '7.1%' },
                workEnvironment: { name: 'Environnement Travail', icon: 'üè†', weight: '7.1%' },
                industry: { name: 'Secteur d\'Activit√©', icon: 'üè≠', weight: '5.4%' },
                availability: { name: 'Disponibilit√©', icon: '‚è∞', weight: '4.5%' },
                contractType: { name: 'Type de Contrat', icon: 'üìã', weight: '4.5%' },
                listenReasons: { name: 'Anti-patterns', icon: 'üé≠', weight: '2.7%' },
                processPosition: { name: 'Position Processus', icon: 'üìà', weight: '1.8%' }
            };
            
            Object.entries(criteriaInfo).forEach(([key, info]) => {
                const criterionData = criteria[key];
                const div = document.createElement('div');
                div.className = 'criteria-item';
                
                if (criterionData && criterionData.score !== null) {
                    div.innerHTML = `
                        <div class="criteria-score ${getScoreClass(criterionData.score)}">
                            ${criterionData.percentage}%
                        </div>
                        <div class="criteria-name">${info.icon} ${info.name}</div>
                        <div class="criteria-details">
                            Poids: ${info.weight}<br>
                            ${criterionData.details}<br>
                            <small style="color: ${criterionData.fallback ? '#d97706' : '#059669'};">
                                ${criterionData.fallback ? '‚ö†Ô∏è Simulation' : '‚úÖ Calcul r√©el'}
                            </small>
                        </div>
                    `;
                } else {
                    div.innerHTML = `
                        <div class="criteria-score score-poor">N/A</div>
                        <div class="criteria-name">${info.icon} ${info.name}</div>
                        <div class="criteria-details">
                            Poids: ${info.weight}<br>
                            Non calcul√©<br>
                            <small style="color: #dc2626;">‚ùå Donn√©es manquantes</small>
                        </div>
                    `;
                    div.style.opacity = '0.5';
                }
                
                container.appendChild(div);
            });
        }
        
        function analyzeCoherence(cvData, jobData, result) {
            const container = document.getElementById('coherenceResults');
            container.innerHTML = '';
            
            const analyses = [
                {
                    test: 'Coh√©rence salariale',
                    check: checkSalaryCoherence(cvData, jobData),
                    description: 'Alignement entre pr√©tentions et offre'
                },
                {
                    test: 'Coh√©rence secteur',
                    check: checkSectorCoherence(cvData, jobData),
                    description: 'Correspondance secteur exp√©rience/cible'
                },
                {
                    test: 'Coh√©rence niveau',
                    check: checkLevelCoherence(cvData, jobData),
                    description: 'Ad√©quation exp√©rience/niveau poste'
                },
                {
                    test: 'Coh√©rence g√©ographique',
                    check: checkLocationCoherence(cvData, jobData),
                    description: 'Faisabilit√© g√©ographique'
                },
                {
                    test: 'Score vs. crit√®res',
                    check: checkScoreCoherence(result),
                    description: 'Coh√©rence score global vs. d√©tail'
                }
            ];
            
            analyses.forEach(analysis => {
                const div = document.createElement('div');
                div.className = 'coherence-item';
                
                div.innerHTML = `
                    <div>
                        <strong>${analysis.test}</strong><br>
                        <small>${analysis.description}</small>
                    </div>
                    <div class="status-indicator ${getStatusClass(analysis.check)}">
                        ${getStatusLabel(analysis.check)}
                    </div>
                `;
                
                container.appendChild(div);
            });
        }
        
        // Fonctions de v√©rification de coh√©rence
        function checkSalaryCoherence(cvData, jobData) {
            const candidateRange = extractSalaryRange(cvData.pretentions_salariales);
            const jobRange = extractSalaryRange(jobData.fourchette_salariale);
            
            if (!candidateRange || !jobRange) return 'warning';
            
            const overlap = calculateSalaryOverlap(candidateRange, jobRange);
            return overlap > 0.3 ? 'success' : overlap > 0 ? 'warning' : 'error';
        }
        
        function checkSectorCoherence(cvData, jobData) {
            const candidateSector = cvData.secteur_actuel;
            const jobSector = jobData.secteur;
            const targetSectors = cvData.secteurs_cibles || [];
            
            if (candidateSector === jobSector || targetSectors.includes(jobSector)) {
                return 'success';
            }
            
            // Secteurs compatibles
            const compatibleSectors = {
                'luxe': ['mode', 'cosmetique'],
                'mode': ['luxe', 'retail'],
                'cosmetique': ['luxe', 'retail'],
                'tech': ['digital', 'startup']
            };
            
            if (compatibleSectors[candidateSector]?.includes(jobSector)) {
                return 'warning';
            }
            
            return 'error';
        }
        
        function checkLevelCoherence(cvData, jobData) {
            const experience = cvData.experience_annees || 5;
            const jobTitle = jobData.titre.toLowerCase();
            
            // D√©tection du niveau du poste
            let requiredExperience = 3;
            if (jobTitle.includes('senior') || jobTitle.includes('directeur')) requiredExperience = 5;
            if (jobTitle.includes('lead') || jobTitle.includes('manager')) requiredExperience = 3;
            if (jobTitle.includes('junior') || jobTitle.includes('assistant')) requiredExperience = 0;
            
            const diff = Math.abs(experience - requiredExperience);
            return diff <= 2 ? 'success' : diff <= 4 ? 'warning' : 'error';
        }
        
        function checkLocationCoherence(cvData, jobData) {
            const candidateCity = cvData.coordonnees?.ville || 'Paris';
            const jobCity = jobData.coordonnees?.ville || 'Paris';
            
            return candidateCity.toLowerCase() === jobCity.toLowerCase() ? 'success' : 'warning';
        }
        
        function checkScoreCoherence(result) {
            const score = result.finalScore;
            const criteriaUsed = result.performance.criteriaUsed;
            
            // V√©rification que le score est coh√©rent avec le nombre de crit√®res
            if (score > 0.9 && criteriaUsed < 8) return 'warning';
            if (score < 0.5 && criteriaUsed > 9) return 'warning';
            
            return 'success';
        }
        
        // Fonctions utilitaires d'affichage
        function getScoreClass(score) {
            if (score >= 0.85) return 'score-excellent';
            if (score >= 0.70) return 'score-good';
            if (score >= 0.55) return 'score-average';
            return 'score-poor';
        }
        
        function getQualityLabel(level) {
            const labels = {
                excellent: 'üèÜ Match Excellent',
                good: '‚úÖ Bon Match',
                average: '‚ö†Ô∏è Match Moyen',
                poor: '‚ùå Match Faible'
            };
            return labels[level] || 'üìä Match Analys√©';
        }
        
        function getStatusClass(status) {
            return `status-${status}`;
        }
        
        function getStatusLabel(status) {
            const labels = {
                success: '‚úÖ Coh√©rent',
                warning: '‚ö†Ô∏è Attention',
                error: '‚ùå Incoh√©rent'
            };
            return labels[status] || '?';
        }
        
        function loadTestExample() {
            // Charger l'exemple de test
            cvData = testExamples.cv;
            jobData = testExamples.job;
            companyData = testExamples.company;
            
            // Remplir les champs
            document.getElementById('cvText').value = `${cvData.nom}
${cvData.email}
Exp√©rience: ${cvData.experience_annees} ans en ${cvData.secteur_actuel}
Poste actuel: ${cvData.poste_actuel}
Comp√©tences: ${cvData.competences.join(', ')}
Pr√©tentions: ${cvData.pretentions_salariales}
Secteurs cibl√©s: ${cvData.secteurs_cibles.join(', ')}
Formations: ${cvData.formations.join(', ')}
Motivations: √âvolution de carri√®re, Innovation, R√©mun√©ration
Adresse: ${cvData.coordonnees.adresse}`;
            
            document.getElementById('jobText').value = `${jobData.titre}
Entreprise: ${jobData.entreprise}
Secteur: ${jobData.secteur}
Salaire: ${jobData.fourchette_salariale}
Comp√©tences: ${jobData.competences_requises.join(', ')}
Mode: ${jobData.mode_travail}
Lieu: ${jobData.coordonnees.adresse}
Missions: ${jobData.missions.join(', ')}`;
            
            // Parser automatiquement
            parseCVData();
            parseJobData();
            
            // Message de confirmation
            setTimeout(() => {
                alert('‚úÖ Exemple de test charg√© ! Vous pouvez maintenant tester le matching.\n\nüìù √âtapes suivantes :\n1. Auto-remplir questionnaires\n2. Lancer matching r√©el');
            }, 500);
        }
    </script>
</body>
</html>