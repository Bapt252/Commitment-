/**
 * NEXTEN V2.0 - QUESTIONNAIRE MAPPER
 * Module de mapping automatique questionnaires → critères V2.0
 * Transformation intelligente des données candidat/entreprise
 */

class QuestionnaireMapper {
    constructor() {
        this.name = 'questionnaire_mapper';
        this.version = '2.0.0';
        
        // === MAPPING CANDIDAT ===\n        this.candidateMapping = {\n            // Données CV Parser existant (pour critères 1-2)\n            cv_parser_data: {\n                target_criteria: ['semantic', 'location'],\n                fields: {\n                    competences: { criteria: 'semantic', weight: 'primary' },\n                    experiences: { criteria: 'semantic', weight: 'primary' },\n                    coordonnees: { criteria: 'location', weight: 'primary' }\n                }\n            },\n            \n            // Questionnaire enrichi (pour critères 3-11)\n            questionnaire_data: {\n                // Critère #3 - Compensation (15%)\n                compensation: {\n                    pretentions_salariales: { field: 'candidateRange', transform: 'parseSalaryRange' },\n                    salaire_actuel: { field: 'currentSalary', transform: 'parseSalary' },\n                    package_souhaite: { field: 'packageElements', transform: 'parsePackage' },\n                    negociation_ouverte: { field: 'negotiationFlexibility', transform: 'parseBoolean' }\n                },\n                \n                // Critère #4 - Motivation (10%)\n                motivation: {\n                    facteurs_motivation: { field: 'priorities', transform: 'parseMotivationList' },\n                    motivation_1: { field: 'firstPriority', transform: 'normalizeMotivation' },\n                    motivation_2: { field: 'secondPriority', transform: 'normalizeMotivation' },\n                    motivation_3: { field: 'thirdPriority', transform: 'normalizeMotivation' },\n                    priorites_carriere: { field: 'careerPriorities', transform: 'parseStringArray' }\n                },\n                \n                // Critère #5 - Company Size (8%)\n                company_size: {\n                    taille_entreprise_preference: { field: 'preferredSize', transform: 'normalizeCompanySize' },\n                    experience_tailles: { field: 'experienceSizes', transform: 'parseExperienceSizes' },\n                    flexibilite_taille: { field: 'sizeFlexibility', transform: 'parseFlexibilityLevel' }\n                },\n                \n                // Critère #6 - Work Environment (8%)\n                work_environment: {\n                    environnement_prefere: { field: 'environmentPreferences', transform: 'parseEnvironmentPrefs' },\n                    teletravail_preference: { field: 'remoteWorkPreference', transform: 'parseRemotePreference' },\n                    type_bureau_prefere: { field: 'officeTypePreference', transform: 'normalizeOfficeType' },\n                    ambiance_souhaitee: { field: 'atmospherePreference', transform: 'normalizeAtmosphere' }\n                },\n                \n                // Critère #7 - Industry (6%)\n                industry: {\n                    secteurs_cibles: { field: 'targetSectors', transform: 'parseSectorArray' },\n                    secteurs_acceptables: { field: 'acceptableSectors', transform: 'parseSectorArray' },\n                    secteurs_redhibitoires: { field: 'avoidSectors', transform: 'parseSectorArray' },\n                    experience_secteurs: { field: 'experienceSectors', transform: 'extractExperienceSectors' }\n                },\n                \n                // Critère #8 - Availability (5%)\n                availability: {\n                    disponibilite: { field: 'availability', transform: 'parseAvailability' },\n                    preavis_actuel: { field: 'currentNotice', transform: 'parseNoticePeriod' },\n                    flexibilite_date: { field: 'dateFlexibility', transform: 'parseFlexibilityLevel' }\n                },\n                \n                // Critère #9 - Contract Type (5%)\n                contract_type: {\n                    type_contrat_souhaite: { field: 'preferredContractType', transform: 'normalizeContractType' },\n                    duree_mission_acceptee: { field: 'acceptedMissionDuration', transform: 'parseDuration' },\n                    flexibilite_contrat: { field: 'contractFlexibility', transform: 'parseFlexibilityLevel' }\n                },\n                \n                // Critère #10 - Listen Reasons (3%)\n                listen_reasons: {\n                    raisons_changement: { field: 'changeReasons', transform: 'parseReasonsList' },\n                    insatisfactions_actuelles: { field: 'currentDissatisfactions', transform: 'parseStringArray' },\n                    motivations_changement: { field: 'changeMotivations', transform: 'parseStringArray' }\n                },\n                \n                // Critère #11 - Process Position (2%)\n                process_position: {\n                    situation_process: { field: 'processStage', transform: 'normalizeProcessStage' },\n                    autres_process_cours: { field: 'otherProcesses', transform: 'parseInteger' },\n                    urgence_decision: { field: 'decisionUrgency', transform: 'parseUrgencyLevel' }\n                }\n            }\n        };\n\n        // === MAPPING ENTREPRISE ===\n        this.companyMapping = {\n            // Données Job Parser existant (pour critères 1-2)\n            job_parser_data: {\n                target_criteria: ['semantic', 'location'],\n                fields: {\n                    competences_requises: { criteria: 'semantic', weight: 'primary' },\n                    description: { criteria: 'semantic', weight: 'secondary' },\n                    coordonnees: { criteria: 'location', weight: 'primary' },\n                    adresse: { criteria: 'location', weight: 'primary' }\n                }\n            },\n            \n            // Questionnaire entreprise enrichi\n            questionnaire_data: {\n                // Critère #3 - Compensation\n                compensation: {\n                    fourchette_salariale: { field: 'salaryRange', transform: 'parseSalaryRange' },\n                    avantages: { field: 'benefits', transform: 'parseBenefitsArray' },\n                    package_total: { field: 'totalPackage', transform: 'parsePackageValue' },\n                    bonus_variables: { field: 'variableBonuses', transform: 'parseBonusStructure' }\n                },\n                \n                // Critère #4 - Motivation\n                motivation: {\n                    valeurs_entreprise: { field: 'companyValues', transform: 'parseValuesArray' },\n                    opportunites_evolution: { field: 'careerOpportunities', transform: 'parseOpportunities' },\n                    culture_innovation: { field: 'innovationCulture', transform: 'parseInnovationLevel' },\n                    management_style: { field: 'managementStyle', transform: 'normalizeManagementStyle' }\n                },\n                \n                // Critère #5 - Company Size\n                company_size: {\n                    effectif: { field: 'employeeCount', transform: 'parseInteger' },\n                    taille_equipe: { field: 'teamSize', transform: 'parseInteger' },\n                    structure_organisation: { field: 'organizationStructure', transform: 'normalizeStructure' },\n                    croissance_effectif: { field: 'growthTrend', transform: 'parseGrowthTrend' }\n                },\n                \n                // Critère #6 - Work Environment\n                work_environment: {\n                    mode_travail: { field: 'workMode', transform: 'parseWorkMode' },\n                    type_bureaux: { field: 'officeType', transform: 'normalizeOfficeType' },\n                    ambiance_travail: { field: 'workAtmosphere', transform: 'normalizeAtmosphere' },\n                    flexibilite_horaires: { field: 'scheduleFlexibility', transform: 'parseFlexibilityType' }\n                },\n                \n                // Critère #7 - Industry\n                industry: {\n                    secteur: { field: 'primarySector', transform: 'normalizeSector' },\n                    sous_secteur: { field: 'subSector', transform: 'normalizeSubSector' },\n                    positionnement_marche: { field: 'marketPosition', transform: 'parseMarketPosition' }\n                },\n                \n                // Critère #8 - Availability\n                availability: {\n                    urgence_recrutement: { field: 'recruitmentUrgency', transform: 'parseUrgencyLevel' },\n                    date_souhaitee_debut: { field: 'desiredStartDate', transform: 'parseDate' },\n                    flexibilite_timing: { field: 'timingFlexibility', transform: 'parseFlexibilityLevel' }\n                },\n                \n                // Critère #9 - Contract Type\n                contract_type: {\n                    type_contrat: { field: 'contractType', transform: 'normalizeContractType' },\n                    duree_mission: { field: 'missionDuration', transform: 'parseDuration' },\n                    possibilite_cdi: { field: 'cdiPossibility', transform: 'parseBoolean' }\n                },\n                \n                // Critère #11 - Process Position\n                process_position: {\n                    processus_recrutement: { field: 'recruitmentProcess', transform: 'parseProcessDetails' },\n                    duree_processus: { field: 'processDuration', transform: 'parseProcessDuration' },\n                    etapes_prevues: { field: 'plannedSteps', transform: 'parseProcessSteps' }\n                }\n            }\n        };\n\n        // Transformateurs de données\n        this.transformers = {\n            // Transformateurs salariaux\n            parseSalaryRange: (value) => this.parseSalaryRange(value),\n            parseSalary: (value) => this.parseSalary(value),\n            \n            // Transformateurs de listes\n            parseStringArray: (value) => this.parseStringArray(value),\n            parseSectorArray: (value) => this.parseSectorArray(value),\n            \n            // Transformateurs de normalisation\n            normalizeCompanySize: (value) => this.normalizeCompanySize(value),\n            normalizeContractType: (value) => this.normalizeContractType(value),\n            normalizeSector: (value) => this.normalizeSector(value),\n            \n            // Transformateurs numériques\n            parseInteger: (value) => this.parseInteger(value),\n            parseBoolean: (value) => this.parseBoolean(value),\n            parseDate: (value) => this.parseDate(value)\n        };\n\n        console.log('📋 QuestionnaireMapper initialisé - Mapping V2.0');\n    }\n\n    /**\n     * MAPPING PRINCIPAL - CANDIDAT\n     * Transformation des données candidat selon mapping V2.0\n     */\n    mapCandidateData(candidateData) {\n        const mappedData = {\n            original: candidateData,\n            criteria_data: {},\n            mapping_quality: 0,\n            mapped_fields: 0,\n            total_fields: 0\n        };\n\n        try {\n            // Mapping données CV Parser (critères existants)\n            mappedData.criteria_data.cv_parser = this.mapCVParserData(candidateData);\n            \n            // Mapping données questionnaire (nouveaux critères)\n            Object.entries(this.candidateMapping.questionnaire_data).forEach(([criterionKey, mapping]) => {\n                mappedData.criteria_data[criterionKey] = this.mapCriterionData(candidateData, mapping);\n                \n                // Comptage qualité mapping\n                const fieldCount = Object.keys(mapping).length;\n                const mappedCount = Object.keys(mappedData.criteria_data[criterionKey]).length;\n                \n                mappedData.total_fields += fieldCount;\n                mappedData.mapped_fields += mappedCount;\n            });\n\n            // Calcul qualité globale du mapping\n            mappedData.mapping_quality = mappedData.total_fields > 0 ? \n                mappedData.mapped_fields / mappedData.total_fields : 0;\n\n            return mappedData;\n\n        } catch (error) {\n            console.error('❌ Erreur mapping candidat:', error);\n            return {\n                original: candidateData,\n                criteria_data: {},\n                mapping_quality: 0,\n                error: error.message\n            };\n        }\n    }\n\n    /**\n     * MAPPING PRINCIPAL - ENTREPRISE\n     * Transformation des données entreprise/poste selon mapping V2.0\n     */\n    mapCompanyData(jobData, companyData = {}) {\n        const mappedData = {\n            original: { job: jobData, company: companyData },\n            criteria_data: {},\n            mapping_quality: 0,\n            mapped_fields: 0,\n            total_fields: 0\n        };\n\n        try {\n            const combinedData = { ...jobData, ...companyData };\n            \n            // Mapping données Job Parser (critères existants)\n            mappedData.criteria_data.job_parser = this.mapJobParserData(combinedData);\n            \n            // Mapping données questionnaire entreprise (nouveaux critères)\n            Object.entries(this.companyMapping.questionnaire_data).forEach(([criterionKey, mapping]) => {\n                mappedData.criteria_data[criterionKey] = this.mapCriterionData(combinedData, mapping);\n                \n                // Comptage qualité mapping\n                const fieldCount = Object.keys(mapping).length;\n                const mappedCount = Object.keys(mappedData.criteria_data[criterionKey]).length;\n                \n                mappedData.total_fields += fieldCount;\n                mappedData.mapped_fields += mappedCount;\n            });\n\n            // Calcul qualité globale du mapping\n            mappedData.mapping_quality = mappedData.total_fields > 0 ? \n                mappedData.mapped_fields / mappedData.total_fields : 0;\n\n            return mappedData;\n\n        } catch (error) {\n            console.error('❌ Erreur mapping entreprise:', error);\n            return {\n                original: { job: jobData, company: companyData },\n                criteria_data: {},\n                mapping_quality: 0,\n                error: error.message\n            };\n        }\n    }\n\n    /**\n     * MAPPING D'UN CRITÈRE SPÉCIFIQUE\n     * Application des transformations sur les champs d'un critère\n     */\n    mapCriterionData(sourceData, criterionMapping) {\n        const mappedCriterion = {};\n\n        Object.entries(criterionMapping).forEach(([sourceField, targetConfig]) => {\n            if (sourceData[sourceField] !== undefined && sourceData[sourceField] !== null) {\n                try {\n                    const transformer = this.transformers[targetConfig.transform];\n                    if (transformer) {\n                        mappedCriterion[targetConfig.field] = transformer(sourceData[sourceField]);\n                    } else {\n                        mappedCriterion[targetConfig.field] = sourceData[sourceField];\n                    }\n                } catch (transformError) {\n                    console.warn(`⚠️ Erreur transformation ${sourceField}:`, transformError);\n                    mappedCriterion[targetConfig.field] = sourceData[sourceField]; // Fallback\n                }\n            }\n        });\n\n        return mappedCriterion;\n    }\n\n    /**\n     * MAPPING CV PARSER (CRITÈRES EXISTANTS)\n     * Mapping des données extraites par le CV Parser v6.2.0\n     */\n    mapCVParserData(candidateData) {\n        return {\n            competences: candidateData.competences || [],\n            experiences: candidateData.experiences || [],\n            coordonnees: candidateData.coordonnees || {},\n            formation: candidateData.formation || [],\n            langues: candidateData.langues || []\n        };\n    }\n\n    /**\n     * MAPPING JOB PARSER (CRITÈRES EXISTANTS)\n     * Mapping des données extraites par le Job Parser GPT\n     */\n    mapJobParserData(jobData) {\n        return {\n            competences_requises: jobData.competences_requises || [],\n            description: jobData.description || '',\n            coordonnees: jobData.coordonnees || jobData.adresse || {},\n            missions: jobData.missions || [],\n            profil_recherche: jobData.profil_recherche || ''\n        };\n    }\n\n    /**\n     * TRANSFORMATEURS DE DONNÉES\n     * Fonctions de transformation spécialisées\n     */\n    \n    parseSalaryRange(salaryInput) {\n        if (!salaryInput) return null;\n        \n        if (typeof salaryInput === 'object' && salaryInput.min && salaryInput.max) {\n            return { min: parseInt(salaryInput.min), max: parseInt(salaryInput.max) };\n        }\n        \n        if (typeof salaryInput === 'string') {\n            const match = salaryInput.match(/(\\d+)k?\\s*[-–]\\s*(\\d+)k?/i);\n            if (match) {\n                return { min: parseInt(match[1]), max: parseInt(match[2]) };\n            }\n            \n            const singleMatch = salaryInput.match(/(\\d+)k?/i);\n            if (singleMatch) {\n                const value = parseInt(singleMatch[1]);\n                return { min: value * 0.9, max: value * 1.1 };\n            }\n        }\n        \n        return null;\n    }\n    \n    parseSalary(salaryInput) {\n        if (!salaryInput) return null;\n        if (typeof salaryInput === 'number') return salaryInput;\n        \n        const match = salaryInput.toString().match(/(\\d+)k?/i);\n        return match ? parseInt(match[1]) : null;\n    }\n    \n    parseStringArray(input) {\n        if (Array.isArray(input)) return input;\n        if (typeof input === 'string') {\n            return input.split(/[,;]/).map(s => s.trim()).filter(s => s);\n        }\n        return [];\n    }\n    \n    parseSectorArray(input) {\n        const sectors = this.parseStringArray(input);\n        return sectors.map(sector => this.normalizeSector(sector)).filter(s => s);\n    }\n    \n    normalizeCompanySize(sizeInput) {\n        if (!sizeInput) return null;\n        \n        const normalized = sizeInput.toString().toLowerCase();\n        if (normalized.includes('startup') || normalized.includes('tpe')) return 'startup';\n        if (normalized.includes('pme')) return 'pme';\n        if (normalized.includes('eti')) return 'eti';\n        if (normalized.includes('groupe') || normalized.includes('grand')) return 'groupe';\n        \n        return null;\n    }\n    \n    normalizeContractType(contractInput) {\n        if (!contractInput) return null;\n        \n        const normalized = contractInput.toString().toLowerCase();\n        if (normalized.includes('cdi')) return 'cdi';\n        if (normalized.includes('cdd')) return 'cdd';\n        if (normalized.includes('freelance')) return 'freelance';\n        if (normalized.includes('stage')) return 'stage';\n        \n        return 'cdi'; // Défaut\n    }\n    \n    normalizeSector(sectorInput) {\n        if (!sectorInput) return null;\n        \n        const normalized = sectorInput.toString().toLowerCase().replace(/[^a-z]/g, '');\n        \n        const sectorMappings = {\n            'luxe': ['luxe', 'luxury'],\n            'mode': ['mode', 'fashion'],\n            'cosmetique': ['cosmetique', 'cosmetic', 'beaute'],\n            'tech': ['tech', 'technologie', 'informatique'],\n            'finance': ['finance', 'banque'],\n            'sante': ['sante', 'health', 'pharma']\n        };\n        \n        for (const [sector, variants] of Object.entries(sectorMappings)) {\n            if (variants.some(variant => normalized.includes(variant))) {\n                return sector;\n            }\n        }\n        \n        return null;\n    }\n    \n    parseInteger(input) {\n        if (typeof input === 'number') return Math.floor(input);\n        if (typeof input === 'string') {\n            const match = input.match(/\\d+/);\n            return match ? parseInt(match[0]) : null;\n        }\n        return null;\n    }\n    \n    parseBoolean(input) {\n        if (typeof input === 'boolean') return input;\n        if (typeof input === 'string') {\n            const normalized = input.toLowerCase();\n            return normalized === 'true' || normalized === 'oui' || normalized === 'yes';\n        }\n        return false;\n    }\n    \n    parseDate(input) {\n        if (!input) return null;\n        try {\n            return new Date(input);\n        } catch {\n            return null;\n        }\n    }\n\n    /**\n     * VALIDATION DU MAPPING\n     * Vérification de la qualité des données mappées\n     */\n    validateMapping(mappedData) {\n        const validation = {\n            isValid: false,\n            quality: mappedData.mapping_quality || 0,\n            coverage: {\n                excellent: mappedData.mapping_quality >= 0.8,\n                good: mappedData.mapping_quality >= 0.6,\n                acceptable: mappedData.mapping_quality >= 0.4,\n                poor: mappedData.mapping_quality < 0.4\n            },\n            recommendations: []\n        };\n\n        // Validation de base\n        validation.isValid = validation.quality >= 0.3; // Minimum 30% de couverture\n\n        // Recommandations d'amélioration\n        if (validation.quality < 0.6) {\n            validation.recommendations.push('Compléter le questionnaire candidat/entreprise');\n        }\n        if (validation.quality < 0.4) {\n            validation.recommendations.push('Utiliser le mode V1 en fallback');\n        }\n\n        return validation;\n    }\n\n    /**\n     * RAPPORT DE MAPPING\n     * Génération d'un rapport détaillé du mapping effectué\n     */\n    generateMappingReport(candidateMapped, companyMapped) {\n        return {\n            candidate: {\n                quality: candidateMapped.mapping_quality,\n                mapped_fields: candidateMapped.mapped_fields,\n                total_fields: candidateMapped.total_fields,\n                coverage_criteria: Object.keys(candidateMapped.criteria_data || {}).length\n            },\n            company: {\n                quality: companyMapped.mapping_quality,\n                mapped_fields: companyMapped.mapped_fields,\n                total_fields: companyMapped.total_fields,\n                coverage_criteria: Object.keys(companyMapped.criteria_data || {}).length\n            },\n            overall: {\n                average_quality: (candidateMapped.mapping_quality + companyMapped.mapping_quality) / 2,\n                total_criteria_covered: new Set([\n                    ...Object.keys(candidateMapped.criteria_data || {}),\n                    ...Object.keys(companyMapped.criteria_data || {})\n                ]).size,\n                recommended_mode: this.recommendMatchingMode(candidateMapped, companyMapped)\n            }\n        };\n    }\n\n    recommendMatchingMode(candidateMapped, companyMapped) {\n        const avgQuality = (candidateMapped.mapping_quality + companyMapped.mapping_quality) / 2;\n        \n        if (avgQuality >= 0.7) return 'v2_full';\n        if (avgQuality >= 0.5) return 'v2_partial';\n        if (avgQuality >= 0.3) return 'v1_enhanced';\n        return 'v1_fallback';\n    }\n}\n\n// Export pour intégration\nif (typeof module !== 'undefined' && module.exports) {\n    module.exports = QuestionnaireMapper;\n}\n\nif (typeof window !== 'undefined') {\n    window.QuestionnaireMapper = QuestionnaireMapper;\n    console.log('📋 QuestionnaireMapper disponible - Mapping automatique V2.0');\n}