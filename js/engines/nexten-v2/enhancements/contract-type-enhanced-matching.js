/**
 * NEXTEN V2.0 OPTIMIZED - ENHANCED CONTRACT TYPE MATCHING
 * Mise √† jour du crit√®re contractType pour int√©grer la logique sophistiqu√©e
 * du questionnaire candidat avec gestion des pr√©f√©rences avanc√©es
 * 
 * @version 2.0-OPTIMIZED-ENHANCED
 * @author NEXTEN Team  
 * @date 2025-06-30
 * 
 * CHANGEMENTS MAJEURS:
 * - Int√©gration compl√®te des donn√©es du questionnaire sophistiqu√©
 * - Scoring nuanc√©: Exact 100%, Pr√©f√©rentiel 80%, Acceptable 70%, Non-match 0%
 * - Gestion des niveaux: exclusive, preferred, acceptable, flexible
 * - Compatibilit√© totale avec l'existant maintenue
 * - Fallbacks intelligents pour les anciennes donn√©es
 */

(function() {
    'use strict';
    
    /**
     * AM√âLIORATION DU CRIT√àRE CONTRACT TYPE POUR NEXTEN V2.0
     * Remplace la m√©thode existante par une version sophistiqu√©e
     */
    function enhanceContractTypeCriterion() {
        
        // V√©rifier que NEXTEN V2.0 est disponible
        if (typeof NextenV2OptimizedSystem === 'undefined') {
            console.warn('‚ö†Ô∏è NEXTEN V2.0 System non trouv√© - mise √† jour report√©e');
            return;
        }
        
        console.log('üîÑ Mise √† jour du crit√®re Contract Type pour NEXTEN V2.0...');
        
        // Configuration du scoring sophistiqu√© selon les exigences
        const scoringConfig = {
            exactMatch: 1.0,        // 100% - Correspondance exacte
            preferential: 0.8,      // 80% - Correspondance pr√©f√©rentielle  
            acceptable: 0.7,        // 70% - Correspondance acceptable
            nonMatch: 0.0          // 0% - Non-correspondance
        };
        
        // Mapping des types de contrats
        const contractTypes = {
            'cdi': 'CDI',
            'cdd': 'CDD', 
            'freelance': 'Freelance',
            'interim': 'Int√©rim'
        };
        
        /**
         * NOUVELLE M√âTHODE calculateContractTypeCriterion SOPHISTIQU√âE
         * Remplace compl√®tement l'ancienne m√©thode (pond√©ration maintenue √† 4.5%)
         */
        NextenV2OptimizedSystem.prototype.calculateContractTypeCriterion = async function(candidateData, jobData, options = {}) {
            const startTime = performance.now();
            
            try {
                console.log('üíº Calcul crit√®re Contract Type sophistiqu√© - NEXTEN V2.0 Enhanced');
                
                // Extraction des donn√©es candidat depuis le questionnaire
                const candidateContractData = extractCandidateContractData(candidateData);
                const jobContractType = extractJobContractType(jobData);
                
                // Validation des donn√©es
                if (!validateContractData(candidateContractData, jobContractType)) {
                    console.warn('‚ö†Ô∏è Donn√©es invalides - fallback activ√©');
                    return getContractFallbackResult(candidateData, jobData);
                }
                
                // Calcul du score sophistiqu√©
                const matchingResult = calculateContractMatchingScore(
                    candidateContractData, 
                    jobContractType
                );
                
                // Construction du r√©sultat final
                const result = {
                    score: matchingResult.score,
                    details: {
                        candidatePreferences: candidateContractData,
                        jobContractType: jobContractType,
                        matchType: matchingResult.matchType,
                        reasoning: matchingResult.reasoning,
                        scoringBreakdown: matchingResult.breakdown,
                        algorithm: "enhanced_contract_matching_v2",
                        calculationTime: performance.now() - startTime,
                        nextenV2Enhanced: true,
                        questionnaireIntegrated: true
                    },
                    confidence: matchingResult.confidence,
                    fallback: false
                };
                
                console.log('‚úÖ Contract Type Score:', result.score);
                console.log('üéØ Match Type:', result.details.matchType);
                
                return result;
                
            } catch (error) {
                console.error('‚ùå Erreur Contract Type sophistiqu√©:', error);
                return getContractFallbackResult(candidateData, jobData);
            }
        };
        
        /**
         * Extraction et parsing des donn√©es contractuelles du candidat
         */
        function extractCandidateContractData(candidateData) {
            // Donn√©es du questionnaire sophistiqu√© (priorit√© 1)
            const contractData = candidateData.contractData || {};
            
            // Donn√©es des champs cach√©s du questionnaire (priorit√© 2)
            const selectedTypesField = candidateData['contract-types-selected'];
            const preferenceLevelField = candidateData['contract-preference-level'];
            const primaryChoiceField = candidateData['contract-primary-choice'];
            
            // Donn√©es legacy (priorit√© 3)
            const legacyContractType = candidateData.contractType || 
                                      candidateData.type_contrat_souhaite;
            
            // Prioriser les nouvelles donn√©es du questionnaire sophistiqu√©
            if (contractData.selectedTypes && contractData.selectedTypes.length > 0) {
                return {
                    selectedTypes: Array.isArray(contractData.selectedTypes) 
                        ? contractData.selectedTypes 
                        : contractData.selectedTypes.split(','),
                    preferenceLevel: contractData.preferenceLevel,
                    primaryChoice: contractData.primaryChoice,
                    isValid: contractData.isValid !== false,
                    source: 'questionnaire_enhanced'
                };
            }
            
            // Utiliser les champs cach√©s du questionnaire
            if (selectedTypesField && preferenceLevelField) {
                return {
                    selectedTypes: selectedTypesField.split(',').filter(t => t.trim()),
                    preferenceLevel: preferenceLevelField,
                    primaryChoice: primaryChoiceField || selectedTypesField.split(',')[0],
                    isValid: true,
                    source: 'questionnaire_fields'
                };
            }
            
            // Fallback vers l'ancien syst√®me
            if (legacyContractType) {
                return {
                    selectedTypes: [legacyContractType],
                    preferenceLevel: 'flexible',
                    primaryChoice: legacyContractType,
                    isValid: true,
                    source: 'legacy_system'
                };
            }
            
            // Donn√©es par d√©faut (CDI flexible)
            return {
                selectedTypes: ['cdi'],
                preferenceLevel: 'flexible',
                primaryChoice: 'cdi',
                isValid: false,
                source: 'default'
            };
        }
        
        /**
         * Extraction du type de contrat du poste
         */
        function extractJobContractType(jobData) {
            return jobData.contractType || 
                   jobData.type_contrat || 
                   jobData.contract_type || 
                   'cdi'; // D√©faut CDI
        }
        
        /**
         * Validation des donn√©es contractuelles
         */
        function validateContractData(candidateContractData, jobContractType) {
            const validTypes = Object.keys(contractTypes);
            
            const candidateTypesValid = candidateContractData.selectedTypes.every(
                type => validTypes.includes(type)
            );
            
            const jobTypeValid = validTypes.includes(jobContractType);
            
            return candidateTypesValid && jobTypeValid;
        }
        
        /**
         * C≈íUR DE LA LOGIQUE : Calcul sophistiqu√© du score de matching
         * Impl√©mente exactement les exigences sp√©cifi√©es
         */
        function calculateContractMatchingScore(candidateContractData, jobContractType) {
            const { selectedTypes, preferenceLevel, primaryChoice } = candidateContractData;
            
            console.log('üìä Calcul scoring contractuel sophistiqu√©:');
            console.log('   Types accept√©s:', selectedTypes);
            console.log('   Niveau pr√©f√©rence:', preferenceLevel);
            console.log('   Choix principal:', primaryChoice);
            console.log('   Type poste:', jobContractType);
            
            // √âTAPE 1: V√©rifier si le type est accept√©
            const isTypeAccepted = selectedTypes.includes(jobContractType);
            
            if (!isTypeAccepted) {
                console.log('‚ùå Type de contrat NON accept√© par le candidat');
                return {
                    score: scoringConfig.nonMatch, // 0%
                    matchType: 'non_match',
                    reasoning: `‚ùå INCOMPATIBLE: Le candidat n'accepte pas le type ${contractTypes[jobContractType]}. Types accept√©s: ${selectedTypes.map(t => contractTypes[t]).join(', ')}`,
                    breakdown: {
                        typeAccepted: false,
                        preferenceLevel: preferenceLevel,
                        selectedTypes: selectedTypes,
                        jobType: jobContractType,
                        finalScore: scoringConfig.nonMatch
                    },
                    confidence: 0.95
                };
            }
            
            console.log('‚úÖ Type de contrat accept√© - calcul du score selon pr√©f√©rence');
            
            // √âTAPE 2: Calcul selon le niveau de pr√©f√©rence (selon exigences)
            let score;
            let matchType;
            let reasoning;
            
            switch (preferenceLevel) {
                case 'exclusive':
                    // üîí MODE EXCLUSIF - Recherche UNIQUEMENT ce type
                    if (selectedTypes.length === 1 && selectedTypes[0] === jobContractType) {
                        score = scoringConfig.exactMatch; // 100%
                        matchType = 'exclusive_perfect_match';
                        reasoning = `üéØ PARFAIT: Correspondance exacte exclusive pour ${contractTypes[jobContractType]}`;
                    } else {
                        // Cas d'erreur du questionnaire - ne devrait pas arriver
                        score = scoringConfig.acceptable; // 70%
                        matchType = 'exclusive_partial';
                        reasoning = `‚ö†Ô∏è Mode exclusif incoh√©rent - score ajust√© pour ${contractTypes[jobContractType]}`;
                    }
                    break;
                    
                case 'preferred':
                    // ‚ù§Ô∏è PR√âF√âRENCE FORTE - Aime particuli√®rement certains types
                    if (primaryChoice === jobContractType) {
                        score = scoringConfig.exactMatch; // 100%
                        matchType = 'primary_preference_match';
                        reasoning = `üåü EXCELLENT: ${contractTypes[jobContractType]} est le type PR√âF√âR√â du candidat`;
                    } else {
                        score = scoringConfig.preferential; // 80%
                        matchType = 'secondary_preference_match';
                        reasoning = `üëç BON: Le candidat accepte ${contractTypes[jobContractType]} mais pr√©f√®re ${contractTypes[primaryChoice]}`;
                    }
                    break;
                    
                case 'acceptable':
                    // ‚úÖ ACCEPTABLE - Trouve ces types corrects sans plus
                    if (primaryChoice === jobContractType) {
                        score = scoringConfig.preferential; // 80%
                        matchType = 'acceptable_primary';
                        reasoning = `üëå BON: ${contractTypes[jobContractType]} est acceptable et correspond au choix principal`;
                    } else {
                        score = scoringConfig.acceptable; // 70%
                        matchType = 'acceptable_secondary';
                        reasoning = `‚úÖ CORRECT: Le candidat trouve les ${contractTypes[jobContractType]} acceptables`;
                    }
                    break;
                    
                case 'flexible':
                    // ü§ù FLEXIBLE - Ouvert √† tous les types s√©lectionn√©s
                    score = scoringConfig.preferential; // 80%
                    matchType = 'flexible_match';
                    reasoning = `ü§ù BON: Le candidat est flexible sur tous ses types s√©lectionn√©s, dont ${contractTypes[jobContractType]}`;
                    break;
                    
                default:
                    // Fallback pour niveau inconnu
                    score = scoringConfig.acceptable; // 70%
                    matchType = 'default_match';
                    reasoning = `‚öôÔ∏è D√âFAUT: Correspondance par d√©faut pour ${contractTypes[jobContractType]}`;
            }
            
            console.log(`üéØ Score final: ${score} (${Math.round(score * 100)}%)`);
            
            return {
                score,
                matchType,
                reasoning,
                breakdown: {
                    typeAccepted: true,
                    preferenceLevel: preferenceLevel,
                    isPrimaryChoice: primaryChoice === jobContractType,
                    selectedTypesCount: selectedTypes.length,
                    jobType: jobContractType,
                    scoringRule: `${preferenceLevel} ‚Üí ${Math.round(score * 100)}%`,
                    finalScore: score
                },
                confidence: 0.90
            };
        }
        
        /**
         * R√©sultat de fallback en cas d'erreur
         */
        function getContractFallbackResult(candidateData, jobData) {
            console.log('üîÑ Activation du fallback Contract Type...');
            
            const candidateType = candidateData.contractType || 
                                candidateData.type_contrat_souhaite || 
                                'cdi';
            const jobType = jobData.contractType || 
                          jobData.type_contrat || 
                          'cdi';
            
            // Matrice de compatibilit√© simple pour fallback
            const simpleCompatibility = {
                cdi: { cdi: 0.95, cdd: 0.6, freelance: 0.3, interim: 0.3 },
                cdd: { cdi: 0.8, cdd: 0.95, freelance: 0.7, interim: 0.6 },
                freelance: { cdi: 0.4, cdd: 0.7, freelance: 0.95, interim: 0.4 },
                interim: { cdi: 0.4, cdd: 0.6, freelance: 0.4, interim: 0.95 }
            };
            
            const score = simpleCompatibility[candidateType]?.[jobType] || 0.7;
            
            return {
                score,
                details: {
                    candidateType,
                    jobType,
                    compatibilityMatrix: simpleCompatibility[candidateType],
                    fallback: true,
                    method: 'simple_compatibility_matrix',
                    reasoning: `Fallback: Compatibilit√© ${candidateType} ‚Üî ${jobType}`,
                    algorithm: "fallback_contract_matching",
                    calculationTime: performance.now() - startTime
                },
                confidence: 0.70,
                fallback: true
            };
        }
        
        console.log('‚úÖ Crit√®re Contract Type sophistiqu√© int√©gr√© dans NEXTEN V2.0');
        console.log('üìä Scoring configur√© selon exigences:');
        console.log('   - Correspondance exacte (candidat cherche CDI + poste CDI): 100%');
        console.log('   - Correspondance pr√©f√©rentielle (candidat pr√©f√®re CDI, accepte CDD + poste CDD): 80%');
        console.log('   - Correspondance acceptable (candidat accepte + poste propose type accept√©): 70%');
        console.log('   - Non-correspondance (candidat refuse ce type): 0%');
        
        return true;
    }
    
    // AUTO-INT√âGRATION INTELLIGENTE
    if (typeof NextenV2OptimizedSystem !== 'undefined') {
        enhanceContractTypeCriterion();
    } else {
        // Attendre que NEXTEN V2.0 soit charg√©
        if (typeof window !== 'undefined') {
            const checkInterval = setInterval(() => {
                if (typeof NextenV2OptimizedSystem !== 'undefined') {
                    enhanceContractTypeCriterion();
                    clearInterval(checkInterval);
                }
            }, 100);
            
            // Timeout apr√®s 5 secondes
            setTimeout(() => {
                clearInterval(checkInterval);
                console.warn('‚è∞ Timeout: NEXTEN V2.0 non trouv√© apr√®s 5 secondes');
            }, 5000);
        }
    }
    
    // Export pour usage manuel si n√©cessaire
    if (typeof window !== 'undefined') {
        window.enhanceNextenContractCriterion = enhanceContractTypeCriterion;
    }
    
    console.log('üíº NEXTEN V2.0 Contract Type Enhancement loaded and ready');
    
})();

/**
 * TESTS DE VALIDATION
 */
function testEnhancedContractMatching() {
    console.log('üß™ Test du matching contractuel sophistiqu√© int√©gr√©');
    
    if (typeof NextenV2OptimizedSystem === 'undefined') {
        console.error('‚ùå NEXTEN V2.0 non disponible pour les tests');
        return;
    }
    
    const nextenSystem = new NextenV2OptimizedSystem();
    
    const testCases = [
        {
            name: "Candidat exclusif CDI vs Poste CDI ‚Üí 100%",
            candidate: {
                'contract-types-selected': 'cdi',
                'contract-preference-level': 'exclusive',
                'contract-primary-choice': 'cdi'
            },
            job: { contractType: 'cdi' },
            expected: 1.0
        },
        {
            name: "Candidat pr√©f√®re CDI, accepte CDD vs Poste CDD ‚Üí 80%",
            candidate: {
                'contract-types-selected': 'cdi,cdd',
                'contract-preference-level': 'preferred',
                'contract-primary-choice': 'cdi'
            },
            job: { contractType: 'cdd' },
            expected: 0.8
        },
        {
            name: "Candidat exclusif CDI vs Poste Freelance ‚Üí 0%",
            candidate: {
                'contract-types-selected': 'cdi',
                'contract-preference-level': 'exclusive',
                'contract-primary-choice': 'cdi'
            },
            job: { contractType: 'freelance' },
            expected: 0.0
        },
        {
            name: "Candidat flexible vs Poste Interim ‚Üí 80%",
            candidate: {
                'contract-types-selected': 'cdi,cdd,interim',
                'contract-preference-level': 'flexible',
                'contract-primary-choice': 'cdi'
            },
            job: { contractType: 'interim' },
            expected: 0.8
        }
    ];
    
    testCases.forEach(async (testCase, index) => {
        console.log(`\nüìã Test ${index + 1}: ${testCase.name}`);
        
        try {
            const result = await nextenSystem.calculateContractTypeCriterion(
                testCase.candidate, 
                testCase.job
            );
            
            console.log(`   Score: ${result.score} (attendu: ${testCase.expected})`);
            console.log(`   Match: ${result.details?.matchType || 'N/A'}`);
            console.log(`   Reasoning: ${result.details?.reasoning || 'N/A'}`);
            
            const success = Math.abs(result.score - testCase.expected) < 0.1;
            console.log(`   ${success ? '‚úÖ R√âUSSI' : '‚ùå √âCHOU√â'}`);
            
        } catch (error) {
            console.error(`   ‚ùå ERREUR: ${error.message}`);
        }
    });
}

// Export de la fonction de test
if (typeof window !== 'undefined') {
    window.testEnhancedContractMatching = testEnhancedContractMatching;
}

console.log('üöÄ Enhanced Contract Matching pour NEXTEN V2.0 charg√© avec succ√®s');
console.log('üß™ Pour tester: testEnhancedContractMatching()');
