/**
 * NEXTEN V2.0 - MOTIVATION MATCHER
 * Crit√®re #4 (10% du score) - Leviers motivation prioritaires candidat
 * Algorithme intelligent de matching des facteurs de motivation
 */

class MotivationMatcher {
    constructor() {
        this.weight = 0.10; // 10% du score total Nexten V2.0
        this.name = 'motivation';
        
        // Facteurs de motivation universels avec pond√©ration prioritaire
        this.motivationFactors = {
            evolution_carriere: {
                label: '√âvolution de carri√®re',
                category: 'development',
                weight_impact: 'high',
                job_indicators: ['promotion', 'senior', 'lead', 'manager', 'directeur', 'evolution', 'carriere']
            },
            equilibre_vie_pro: {
                label: '√âquilibre vie professionnelle/personnelle',
                category: 'lifestyle',
                weight_impact: 'high',
                job_indicators: ['flexible', 'remote', 'teletravail', 'equilibre', 'work-life', 'horaires']
            },
            remuneration: {
                label: 'R√©mun√©ration attractive',
                category: 'financial',
                weight_impact: 'high',
                job_indicators: ['salaire', 'bonus', 'prime', 'remuneration', 'competitive', 'attractive']
            },
            innovation_creativite: {
                label: 'Innovation et cr√©ativit√©',
                category: 'intellectual',
                weight_impact: 'medium',
                job_indicators: ['innovation', 'creative', 'design', 'nouveau', 'startup', 'disruptif']
            },
            management_equipe: {
                label: 'Management d\\'√©quipe',
                category: 'leadership',
                weight_impact: 'medium',
                job_indicators: ['manager', 'equipe', 'leadership', 'responsable', 'diriger', 'team']
            },
            formation_apprentissage: {
                label: 'Formation et apprentissage',
                category: 'development',
                weight_impact: 'medium',
                job_indicators: ['formation', 'apprentissage', 'training', 'skill', 'competence', 'certification']
            },
            reconnaissance_impact: {
                label: 'Reconnaissance et impact',
                category: 'achievement',
                weight_impact: 'medium',
                job_indicators: ['impact', 'reconnaissance', 'visible', 'reputation', 'expertise', 'influence']
            },
            stabilite_securite: {
                label: 'Stabilit√© et s√©curit√©',
                category: 'security',
                weight_impact: 'medium',
                job_indicators: ['stable', 'securite', 'CDI', 'permanente', 'etabli', 'fiable']
            },
            autonomie_responsabilite: {
                label: 'Autonomie et responsabilit√©',
                category: 'independence',
                weight_impact: 'medium',
                job_indicators: ['autonome', 'responsabilite', 'independant', 'decision', 'freedom', 'flexible']
            },
            environnement_travail: {
                label: 'Environnement de travail stimulant',
                category: 'environment',
                weight_impact: 'medium',
                job_indicators: ['environnement', 'culture', 'atmosphere', 'collaboratif', 'moderne', 'innovant']
            },
            mission_sens: {
                label: 'Mission et sens',
                category: 'purpose',
                weight_impact: 'low',
                job_indicators: ['mission', 'sens', 'purpose', 'valeurs', 'societal', 'impact', 'meaningful']
            },
            challenge_defis: {
                label: 'Challenges et d√©fis',
                category: 'achievement',
                weight_impact: 'low',
                job_indicators: ['challenge', 'defi', 'complexe', 'ambitieux', 'difficult', 'technique']
            }
        };\n\n        // Pond√©ration par priorit√© candidat\n        this.priorityWeights = {\n            first: 0.50,   // 50% du score pour la motivation #1\n            second: 0.30,  // 30% du score pour la motivation #2\n            third: 0.20    // 20% du score pour la motivation #3\n        };\n\n        // Secteurs et leurs motivations typiques\n        this.sectorMotivationProfiles = {\n            luxe: {\n                primary: ['reconnaissance_impact', 'innovation_creativite', 'remuneration'],\n                secondary: ['environnement_travail', 'evolution_carriere'],\n                avoid: ['stabilite_securite']\n            },\n            mode: {\n                primary: ['innovation_creativite', 'reconnaissance_impact', 'environnement_travail'],\n                secondary: ['evolution_carriere', 'autonomie_responsabilite'],\n                avoid: ['stabilite_securite']\n            },\n            tech: {\n                primary: ['innovation_creativite', 'challenge_defis', 'formation_apprentissage'],\n                secondary: ['remuneration', 'autonomie_responsabilite'],\n                avoid: []\n            },\n            finance: {\n                primary: ['remuneration', 'evolution_carriere', 'stabilite_securite'],\n                secondary: ['reconnaissance_impact', 'challenge_defis'],\n                avoid: ['equilibre_vie_pro']\n            },\n            startup: {\n                primary: ['innovation_creativite', 'autonomie_responsabilite', 'challenge_defis'],\n                secondary: ['evolution_carriere', 'reconnaissance_impact'],\n                avoid: ['stabilite_securite', 'equilibre_vie_pro']\n            }\n        };\n\n        // Cache des analyses de motivation\n        this.motivationCache = new Map();\n        \n        // M√©triques de performance\n        this.metrics = {\n            totalAnalyses: 0,\n            averageAnalysisTime: 0,\n            cacheHitRate: 0,\n            matchingAccuracy: 0\n        };\n\n        console.log('üéØ MotivationMatcher initialis√© - Crit√®re #4 (10%)');\n    }\n\n    /**\n     * CALCUL PRINCIPAL DU SCORE DE MOTIVATION\n     * Analyse intelligente des leviers de motivation candidat vs offre\n     */\n    async calculateMotivationScore(candidateData, jobData, companyData = {}) {\n        const startTime = performance.now();\n        \n        try {\n            // Cache check\n            const cacheKey = this.generateMotivationCacheKey(candidateData, jobData, companyData);\n            const cached = this.motivationCache.get(cacheKey);\n            if (cached && this.isCacheValid(cached)) {\n                this.updateMetrics(performance.now() - startTime, true);\n                return cached.result;\n            }\n\n            // Extraction des motivations candidat\n            const candidateMotivations = this.extractCandidateMotivations(candidateData);\n            \n            // Analyse du potentiel motivationnel de l'offre\n            const jobMotivationPotential = this.analyzeJobMotivationPotential(jobData, companyData);\n            \n            if (!this.validateMotivationData(candidateMotivations, jobMotivationPotential)) {\n                return this.getFallbackScore('Donn√©es motivation insuffisantes');\n            }\n\n            // Calcul du matching par priorit√©\n            const priorityMatchingScores = this.calculatePriorityMatching(candidateMotivations, jobMotivationPotential);\n            \n            // Analyse sectorielle de coh√©rence\n            const sectorAlignment = this.calculateSectorMotivationAlignment(candidateMotivations, jobData, companyData);\n            \n            // D√©tection anti-patterns (motivations incompatibles)\n            const antiPatternAnalysis = this.detectMotivationAntiPatterns(candidateMotivations, jobMotivationPotential);\n            \n            // Score composite final\n            const finalScore = this.computeFinalMotivationScore({\n                priorityScores: priorityMatchingScores,\n                sectorAlignment: sectorAlignment,\n                antiPatterns: antiPatternAnalysis\n            });\n\n            const result = {\n                finalScore: Math.min(finalScore, 1.0),\n                priorityBreakdown: {\n                    first_priority: priorityMatchingScores.first,\n                    second_priority: priorityMatchingScores.second,\n                    third_priority: priorityMatchingScores.third\n                },\n                motivationAnalysis: {\n                    candidate_motivations: candidateMotivations,\n                    job_potential: jobMotivationPotential,\n                    sector_alignment: sectorAlignment,\n                    anti_patterns: antiPatternAnalysis\n                },\n                insights: {\n                    motivation_strengths: this.identifyMotivationStrengths(candidateMotivations, jobMotivationPotential),\n                    motivation_gaps: this.identifyMotivationGaps(candidateMotivations, jobMotivationPotential),\n                    recommendations: this.generateMotivationRecommendations(candidateMotivations, jobMotivationPotential, finalScore)\n                },\n                performance: {\n                    analysisTime: performance.now() - startTime,\n                    dataQuality: this.assessMotivationDataQuality(candidateMotivations, jobMotivationPotential),\n                    confidence: this.calculateMotivationConfidence(candidateMotivations, jobMotivationPotential)\n                }\n            };\n\n            // Mise en cache\n            this.motivationCache.set(cacheKey, {\n                result: result,\n                timestamp: Date.now()\n            });\n\n            this.updateMetrics(performance.now() - startTime, false);\n            return result;\n\n        } catch (error) {\n            console.error('‚ùå Erreur MotivationMatcher:', error);\n            return this.getFallbackScore(`Erreur analyse: ${error.message}`);\n        }\n    }\n\n    /**\n     * EXTRACTION DES MOTIVATIONS CANDIDAT\n     * Analyse des priorit√©s et facteurs motivationnels\n     */\n    extractCandidateMotivations(candidateData) {\n        const motivations = {\n            priorities: [],\n            declared: [],\n            inferred: []\n        };\n\n        // Motivations explicites du questionnaire\n        if (candidateData.motivations) {\n            if (Array.isArray(candidateData.motivations)) {\n                motivations.priorities = candidateData.motivations.slice(0, 3); // Top 3\n            } else if (typeof candidateData.motivations === 'object') {\n                motivations.priorities = [\n                    candidateData.motivations.first,\n                    candidateData.motivations.second,\n                    candidateData.motivations.third\n                ].filter(m => m);\n            }\n        }\n\n        // Facteurs motivationnels d√©clar√©s\n        if (candidateData.facteurs_motivation) {\n            motivations.declared = candidateData.facteurs_motivation;\n        }\n\n        // Motivations inf√©r√©es des autres donn√©es\n        motivations.inferred = this.inferMotivationsFromProfile(candidateData);\n\n        // Consolidation et normalisation\n        return this.consolidateMotivations(motivations);\n    }\n\n    /**\n     * ANALYSE DU POTENTIEL MOTIVATIONNEL DE L'OFFRE\n     * √âvaluation des facteurs motivationnels que peut satisfaire le poste\n     */\n    analyzeJobMotivationPotential(jobData, companyData) {\n        const potential = {};\n\n        // Analyse de chaque facteur de motivation\n        Object.keys(this.motivationFactors).forEach(factorKey => {\n            const factor = this.motivationFactors[factorKey];\n            potential[factorKey] = this.calculateFactorPotential(factor, jobData, companyData);\n        });\n\n        return potential;\n    }\n\n    /**\n     * CALCUL DU POTENTIEL D'UN FACTEUR\n     * Score de 0 √† 1 pour chaque facteur de motivation\n     */\n    calculateFactorPotential(factor, jobData, companyData) {\n        let score = 0.3; // Score de base\n        \n        // Analyse textuelle de la description de poste\n        const jobText = (\n            (jobData.description || '') + ' ' +\n            (jobData.missions || '') + ' ' +\n            (jobData.titre || '') + ' ' +\n            (companyData.description || '') + ' ' +\n            (companyData.valeurs || '')\n        ).toLowerCase();\n\n        // Recherche d'indicateurs dans le texte\n        let indicatorMatches = 0;\n        factor.job_indicators.forEach(indicator => {\n            if (jobText.includes(indicator)) {\n                indicatorMatches++;\n            }\n        });\n\n        // Score bas√© sur les indicateurs trouv√©s\n        if (indicatorMatches > 0) {\n            score += Math.min(indicatorMatches * 0.2, 0.6); // Max +60%\n        }\n\n        // Ajustements sp√©cifiques par facteur\n        score += this.getFactorSpecificAdjustments(factor, jobData, companyData);\n\n        return Math.min(score, 1.0);\n    }\n\n    /**\n     * CALCUL MATCHING PAR PRIORIT√â\n     * Score pond√©r√© selon l'ordre des priorit√©s candidat\n     */\n    calculatePriorityMatching(candidateMotivations, jobMotivationPotential) {\n        const scores = {\n            first: 0,\n            second: 0,\n            third: 0\n        };\n\n        // Matching priorit√© #1 (50% du score)\n        if (candidateMotivations.priorities[0]) {\n            const motivation = candidateMotivations.priorities[0];\n            scores.first = jobMotivationPotential[motivation] || 0;\n        }\n\n        // Matching priorit√© #2 (30% du score)\n        if (candidateMotivations.priorities[1]) {\n            const motivation = candidateMotivations.priorities[1];\n            scores.second = jobMotivationPotential[motivation] || 0;\n        }\n\n        // Matching priorit√© #3 (20% du score)\n        if (candidateMotivations.priorities[2]) {\n            const motivation = candidateMotivations.priorities[2];\n            scores.third = jobMotivationPotential[motivation] || 0;\n        }\n\n        return scores;\n    }\n\n    /**\n     * ALIGNEMENT SECTORIEL DES MOTIVATIONS\n     * V√©rification coh√©rence motivations vs profil sectoriel\n     */\n    calculateSectorMotivationAlignment(candidateMotivations, jobData, companyData) {\n        const sector = this.extractSector(jobData, companyData);\n        const sectorProfile = this.sectorMotivationProfiles[sector];\n        \n        if (!sectorProfile) {\n            return 0.7; // Score neutre si secteur inconnu\n        }\n\n        let alignmentScore = 0.5;\n        \n        // Bonus si motivations candidates correspondent aux motivations sectorielles primaires\n        candidateMotivations.priorities.forEach(motivation => {\n            if (sectorProfile.primary.includes(motivation)) {\n                alignmentScore += 0.15; // +15% par motivation primaire align√©e\n            } else if (sectorProfile.secondary.includes(motivation)) {\n                alignmentScore += 0.05; // +5% par motivation secondaire align√©e\n            } else if (sectorProfile.avoid && sectorProfile.avoid.includes(motivation)) {\n                alignmentScore -= 0.1; // -10% par motivation √† √©viter\n            }\n        });\n\n        return Math.max(Math.min(alignmentScore, 1.0), 0.1);\n    }\n\n    /**\n     * D√âTECTION ANTI-PATTERNS MOTIVATIONNELS\n     * Identification des incompatibilit√©s flagrantes\n     */\n    detectMotivationAntiPatterns(candidateMotivations, jobMotivationPotential) {\n        const antiPatterns = {\n            detected: [],\n            severity: 'none',\n            impact: 0\n        };\n\n        // Anti-pattern: Motivation forte + Potentiel tr√®s faible\n        candidateMotivations.priorities.forEach((motivation, index) => {\n            const potential = jobMotivationPotential[motivation] || 0;\n            const priority = index === 0 ? 'high' : index === 1 ? 'medium' : 'low';\n            \n            if (potential < 0.3 && priority === 'high') {\n                antiPatterns.detected.push({\n                    type: 'high_priority_low_potential',\n                    motivation: motivation,\n                    severity: 'high',\n                    description: `Motivation prioritaire \"${this.motivationFactors[motivation]?.label}\" peu satisfaite`\n                });\n                antiPatterns.impact += 0.3;\n            } else if (potential < 0.4 && priority === 'medium') {\n                antiPatterns.detected.push({\n                    type: 'medium_priority_low_potential',\n                    motivation: motivation,\n                    severity: 'medium',\n                    description: `Motivation secondaire \"${this.motivationFactors[motivation]?.label}\" insuffisamment satisfaite`\n                });\n                antiPatterns.impact += 0.15;\n            }\n        });\n\n        // D√©termination s√©v√©rit√© globale\n        if (antiPatterns.impact >= 0.4) {\n            antiPatterns.severity = 'high';\n        } else if (antiPatterns.impact >= 0.2) {\n            antiPatterns.severity = 'medium';\n        } else if (antiPatterns.impact > 0) {\n            antiPatterns.severity = 'low';\n        }\n\n        return antiPatterns;\n    }\n\n    /**\n     * SCORE COMPOSITE FINAL MOTIVATION\n     * Combinaison pond√©r√©e des diff√©rents √©l√©ments\n     */\n    computeFinalMotivationScore(components) {\n        const { priorityScores, sectorAlignment, antiPatterns } = components;\n        \n        // Score de base selon priorit√©s\n        const baseScore = (\n            priorityScores.first * this.priorityWeights.first +\n            priorityScores.second * this.priorityWeights.second +\n            priorityScores.third * this.priorityWeights.third\n        );\n\n        // Ajustement sectoriel\n        const sectorAdjustedScore = baseScore * (0.7 + sectorAlignment * 0.3);\n\n        // P√©nalit√© anti-patterns\n        const finalScore = sectorAdjustedScore * (1 - antiPatterns.impact * 0.5);\n\n        return Math.max(Math.min(finalScore, 1.0), 0.1);\n    }\n\n    /**\n     * UTILITAIRES ET M√âTHODES HELPER\n     */\n    inferMotivationsFromProfile(candidateData) {\n        const inferred = [];\n        \n        // Inf√©rence bas√©e sur l'exp√©rience\n        if (candidateData.experiences) {\n            // Logique d'inf√©rence √† d√©velopper\n        }\n        \n        // Inf√©rence bas√©e sur la situation actuelle\n        if (candidateData.raisons_changement) {\n            // Logique d'inf√©rence √† d√©velopper\n        }\n        \n        return inferred;\n    }\n\n    consolidateMotivations(motivations) {\n        // Priorit√©s explicites en premier\n        const consolidated = {\n            priorities: motivations.priorities.slice(0, 3),\n            all_factors: [...motivations.declared, ...motivations.inferred]\n        };\n        \n        // Compl√©ter les priorit√©s si n√©cessaire\n        while (consolidated.priorities.length < 3 && motivations.declared.length > 0) {\n            const next = motivations.declared.shift();\n            if (!consolidated.priorities.includes(next)) {\n                consolidated.priorities.push(next);\n            }\n        }\n        \n        return consolidated;\n    }\n\n    getFactorSpecificAdjustments(factor, jobData, companyData) {\n        // Ajustements sp√©cifiques par facteur\n        switch (factor.category) {\n            case 'financial':\n                return this.getFinancialAdjustment(jobData, companyData);\n            case 'development':\n                return this.getDevelopmentAdjustment(jobData, companyData);\n            case 'lifestyle':\n                return this.getLifestyleAdjustment(jobData, companyData);\n            default:\n                return 0;\n        }\n    }\n\n    extractSector(jobData, companyData) {\n        return jobData.secteur || jobData.sector || companyData.secteur || companyData.sector || 'default';\n    }\n\n    // M√©thodes placeholder\n    getFinancialAdjustment(jobData, companyData) { return 0.1; }\n    getDevelopmentAdjustment(jobData, companyData) { return 0.05; }\n    getLifestyleAdjustment(jobData, companyData) { return 0.05; }\n    identifyMotivationStrengths(candidateMotivations, jobMotivationPotential) { return []; }\n    identifyMotivationGaps(candidateMotivations, jobMotivationPotential) { return []; }\n    generateMotivationRecommendations(candidateMotivations, jobMotivationPotential, finalScore) { return []; }\n    assessMotivationDataQuality(candidateMotivations, jobMotivationPotential) { return 0.8; }\n    calculateMotivationConfidence(candidateMotivations, jobMotivationPotential) { return 0.85; }\n\n    generateMotivationCacheKey(candidateData, jobData, companyData) {\n        const key = JSON.stringify({\n            motivations: candidateData.motivations,\n            job_desc: jobData.description?.substring(0, 100),\n            sector: jobData.secteur\n        });\n        return btoa(key).substring(0, 20);\n    }\n\n    isCacheValid(cached) {\n        return (Date.now() - cached.timestamp) < 600000; // 10 minutes\n    }\n\n    validateMotivationData(candidateMotivations, jobMotivationPotential) {\n        return candidateMotivations.priorities.length > 0 || Object.keys(jobMotivationPotential).length > 0;\n    }\n\n    getFallbackScore(reason) {\n        return {\n            finalScore: 0.5,\n            error: reason,\n            fallback: true,\n            timestamp: new Date().toISOString()\n        };\n    }\n\n    updateMetrics(analysisTime, wasCacheHit) {\n        this.metrics.totalAnalyses++;\n        this.metrics.averageAnalysisTime = \n            (this.metrics.averageAnalysisTime * (this.metrics.totalAnalyses - 1) + analysisTime) \n            / this.metrics.totalAnalyses;\n            \n        if (wasCacheHit) {\n            this.metrics.cacheHitRate = \n                (this.metrics.cacheHitRate * (this.metrics.totalAnalyses - 1) + 1) \n                / this.metrics.totalAnalyses;\n        }\n    }\n}\n\n// Export pour int√©gration\nif (typeof module !== 'undefined' && module.exports) {\n    module.exports = MotivationMatcher;\n}\n\nif (typeof window !== 'undefined') {\n    window.MotivationMatcher = MotivationMatcher;\n    console.log('üéØ MotivationMatcher disponible - Crit√®re #4 (10%)');\n}