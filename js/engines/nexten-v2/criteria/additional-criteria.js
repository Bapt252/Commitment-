/**\n * NEXTEN V2.0 - AVAILABILITY MATCHER\n * Crit√®re #8 (5% du score) - Urgence vs d√©lai candidat\n * Algorithme intelligent de matching des disponibilit√©s\n */\n\nclass AvailabilityMatcher {\n    constructor() {\n        this.weight = 0.05;\n        this.name = 'availability';\n        \n        // Niveaux d'urgence entreprise\n        this.urgencyLevels = {\n            immediate: { days: 15, label: 'Imm√©diat (0-15j)', priority: 'critical' },\n            urgent: { days: 30, label: 'Urgent (15-30j)', priority: 'high' },\n            normal: { days: 60, label: 'Normal (30-60j)', priority: 'medium' },\n            flexible: { days: 90, label: 'Flexible (60j+)', priority: 'low' }\n        };\n        \n        // Disponibilit√©s candidat\n        this.availabilityTypes = {\n            available_now: { days: 0, flexibility: 'none' },\n            notice_1_month: { days: 30, flexibility: 'low' },\n            notice_2_months: { days: 60, flexibility: 'medium' },\n            notice_3_months: { days: 90, flexibility: 'high' },\n            negotiable: { days: 45, flexibility: 'very_high' }\n        };\n        \n        console.log('‚è∞ AvailabilityMatcher initialis√© - Crit√®re #8 (5%)');\n    }\n    \n    async calculateAvailabilityScore(candidateData, jobData, companyData = {}) {\n        try {\n            const candidateAvailability = this.extractCandidateAvailability(candidateData);\n            const jobUrgency = this.extractJobUrgency(jobData, companyData);\n            \n            // Calcul score de compatibilit√© temporelle\n            const timeCompatibility = this.calculateTimeCompatibility(candidateAvailability, jobUrgency);\n            \n            // Facteur de flexibilit√©\n            const flexibilityBonus = this.calculateFlexibilityBonus(candidateAvailability, jobUrgency);\n            \n            const finalScore = Math.min(timeCompatibility + flexibilityBonus, 1.0);\n            \n            return {\n                finalScore: finalScore,\n                details: {\n                    candidate_availability: candidateAvailability,\n                    job_urgency: jobUrgency,\n                    time_compatibility: timeCompatibility,\n                    flexibility_bonus: flexibilityBonus\n                }\n            };\n        } catch (error) {\n            return { finalScore: 0.5, error: error.message };\n        }\n    }\n    \n    extractCandidateAvailability(candidateData) {\n        const availabilityStr = candidateData.disponibilite || candidateData.availability || 'notice_2_months';\n        \n        // Parse des formats courants\n        if (availabilityStr.includes('imm√©diat') || availabilityStr.includes('immediate')) {\n            return { type: 'available_now', days: 0 };\n        }\n        if (availabilityStr.includes('1') && availabilityStr.includes('mois')) {\n            return { type: 'notice_1_month', days: 30 };\n        }\n        if (availabilityStr.includes('2') && availabilityStr.includes('mois')) {\n            return { type: 'notice_2_months', days: 60 };\n        }\n        if (availabilityStr.includes('3') && availabilityStr.includes('mois')) {\n            return { type: 'notice_3_months', days: 90 };\n        }\n        \n        return { type: 'notice_2_months', days: 60 }; // D√©faut\n    }\n    \n    extractJobUrgency(jobData, companyData) {\n        const urgencyStr = jobData.urgence_recrutement || jobData.urgency || 'normal';\n        \n        if (urgencyStr.includes('imm√©diat') || urgencyStr.includes('urgent')) {\n            return { type: 'urgent', days: 30 };\n        }\n        if (urgencyStr.includes('flexible')) {\n            return { type: 'flexible', days: 90 };\n        }\n        \n        return { type: 'normal', days: 60 };\n    }\n    \n    calculateTimeCompatibility(candidateAvailability, jobUrgency) {\n        const daysDiff = candidateAvailability.days - jobUrgency.days;\n        \n        if (daysDiff <= 0) return 1.0;        // Candidat plus rapide = parfait\n        if (daysDiff <= 15) return 0.9;       // √âcart < 15j = excellent\n        if (daysDiff <= 30) return 0.7;       // √âcart < 30j = bon\n        if (daysDiff <= 60) return 0.5;       // √âcart < 60j = acceptable\n        return 0.3;                           // √âcart > 60j = faible\n    }\n    \n    calculateFlexibilityBonus(candidateAvailability, jobUrgency) {\n        // Bonus si candidat flexible ou si urgence faible\n        if (candidateAvailability.type === 'negotiable') return 0.1;\n        if (jobUrgency.type === 'flexible') return 0.05;\n        return 0;\n    }\n}\n\n/**\n * NEXTEN V2.0 - CONTRACT TYPE MATCHER\n * Crit√®re #9 (5% du score) - CDI/CDD/Freelance compatibilit√©\n * Algorithme intelligent de matching des types de contrats\n */\n\nclass ContractTypeMatcher {\n    constructor() {\n        this.weight = 0.05;\n        this.name = 'contractType';\n        \n        // Types de contrats avec caract√©ristiques\n        this.contractTypes = {\n            cdi: {\n                label: 'CDI',\n                stability: 'very_high',\n                flexibility: 'low',\n                benefits: 'full',\n                career_progression: 'high'\n            },\n            cdd: {\n                label: 'CDD',\n                stability: 'medium',\n                flexibility: 'medium',\n                benefits: 'partial',\n                career_progression: 'medium'\n            },\n            freelance: {\n                label: 'Freelance',\n                stability: 'low',\n                flexibility: 'very_high',\n                benefits: 'minimal',\n                career_progression: 'external'\n            },\n            interim: {\n                label: 'Int√©rim',\n                stability: 'very_low',\n                flexibility: 'maximum',\n                benefits: 'minimal',\n                career_progression: 'none'\n            },\n            stage: {\n                label: 'Stage',\n                stability: 'temporary',\n                flexibility: 'high',\n                benefits: 'educational',\n                career_progression: 'learning'\n            }\n        };\n        \n        console.log('üìã ContractTypeMatcher initialis√© - Crit√®re #9 (5%)');\n    }\n    \n    async calculateContractTypeScore(candidateData, jobData, companyData = {}) {\n        try {\n            const candidatePreference = this.extractCandidateContractPreference(candidateData);\n            const jobContractType = this.extractJobContractType(jobData);\n            \n            // Matching direct des types de contrats\n            const directMatch = this.calculateDirectContractMatch(candidatePreference, jobContractType);\n            \n            // Compatibilit√© des caract√©ristiques\n            const characteristicsMatch = this.calculateCharacteristicsMatch(candidatePreference, jobContractType);\n            \n            const finalScore = (directMatch * 0.7 + characteristicsMatch * 0.3);\n            \n            return {\n                finalScore: finalScore,\n                details: {\n                    candidate_preference: candidatePreference,\n                    job_contract: jobContractType,\n                    direct_match: directMatch,\n                    characteristics_match: characteristicsMatch\n                }\n            };\n        } catch (error) {\n            return { finalScore: 0.5, error: error.message };\n        }\n    }\n    \n    extractCandidateContractPreference(candidateData) {\n        const preference = candidateData.type_contrat_souhaite || candidateData.contract_preference || 'cdi';\n        return this.normalizeContractType(preference);\n    }\n    \n    extractJobContractType(jobData) {\n        const contractType = jobData.type_contrat || jobData.contract_type || 'cdi';\n        return this.normalizeContractType(contractType);\n    }\n    \n    normalizeContractType(contractStr) {\n        const normalized = contractStr.toLowerCase();\n        \n        if (normalized.includes('cdi')) return 'cdi';\n        if (normalized.includes('cdd')) return 'cdd';\n        if (normalized.includes('freelance') || normalized.includes('ind√©pendant')) return 'freelance';\n        if (normalized.includes('int√©rim') || normalized.includes('interim')) return 'interim';\n        if (normalized.includes('stage')) return 'stage';\n        \n        return 'cdi'; // D√©faut\n    }\n    \n    calculateDirectContractMatch(candidatePreference, jobContractType) {\n        if (candidatePreference === jobContractType) return 1.0;\n        \n        // Matrice de compatibilit√© des contrats\n        const compatibility = {\n            cdi: { cdi: 1.0, cdd: 0.7, freelance: 0.3, interim: 0.2, stage: 0.1 },\n            cdd: { cdi: 0.8, cdd: 1.0, freelance: 0.6, interim: 0.7, stage: 0.5 },\n            freelance: { cdi: 0.4, cdd: 0.6, freelance: 1.0, interim: 0.8, stage: 0.3 },\n            interim: { cdi: 0.3, cdd: 0.7, freelance: 0.8, interim: 1.0, stage: 0.4 },\n            stage: { cdi: 0.6, cdd: 0.8, freelance: 0.5, interim: 0.6, stage: 1.0 }\n        };\n        \n        return compatibility[candidatePreference]?.[jobContractType] || 0.5;\n    }\n    \n    calculateCharacteristicsMatch(candidatePreference, jobContractType) {\n        // Analyse de la compatibilit√© des caract√©ristiques\n        const candidateContract = this.contractTypes[candidatePreference];\n        const jobContract = this.contractTypes[jobContractType];\n        \n        if (!candidateContract || !jobContract) return 0.5;\n        \n        // Score bas√© sur la similarit√© des caract√©ristiques\n        let score = 0.5;\n        \n        if (candidateContract.stability === jobContract.stability) score += 0.2;\n        if (candidateContract.flexibility === jobContract.flexibility) score += 0.2;\n        if (candidateContract.benefits === jobContract.benefits) score += 0.1;\n        \n        return Math.min(score, 1.0);\n    }\n}\n\n/**\n * NEXTEN V2.0 - LISTEN REASONS MATCHER\n * Crit√®re #10 (3% du score) - Anti-patterns intelligents\n * Algorithme de d√©tection des raisons d'√©coute probl√©matiques\n */\n\nclass ListenReasonsMatcher {\n    constructor() {\n        this.weight = 0.03;\n        this.name = 'listenReasons';\n        \n        // Anti-patterns avec actions recommand√©es\n        this.antiPatterns = {\n            distance_trop_importante: {\n                severity: 'high',\n                suggestion: 'Proposer postes proches ou t√©l√©travail',\n                action: 'geo_filtering',\n                weight: 0.8\n            },\n            salaire_insuffisant: {\n                severity: 'high',\n                suggestion: 'Revoir fourchette salariale',\n                action: 'compensation_adjustment',\n                weight: 0.7\n            },\n            manque_evolution: {\n                severity: 'medium',\n                suggestion: 'Mettre en avant les opportunit√©s',\n                action: 'career_focus',\n                weight: 0.6\n            },\n            environnement_inadapte: {\n                severity: 'medium',\n                suggestion: 'D√©tailler l\\'environnement de travail',\n                action: 'environment_clarification',\n                weight: 0.5\n            },\n            secteur_ininteressant: {\n                severity: 'high',\n                suggestion: 'Cibler autres secteurs',\n                action: 'sector_filtering',\n                weight: 0.9\n            }\n        };\n        \n        console.log('üé≠ ListenReasonsMatcher initialis√© - Crit√®re #10 (3%)');\n    }\n    \n    async calculateListenReasonsScore(candidateData, jobData, companyData = {}) {\n        try {\n            const listenReasons = this.extractListenReasons(candidateData);\n            const antiPatternsDetected = this.detectAntiPatterns(listenReasons, jobData, companyData);\n            \n            // Score bas√© sur l'absence d'anti-patterns\n            let score = 1.0;\n            \n            antiPatternsDetected.forEach(pattern => {\n                score -= (pattern.weight * 0.3); // R√©duction maximale de 30% par pattern\n            });\n            \n            const finalScore = Math.max(score, 0.2); // Score minimum de 20%\n            \n            return {\n                finalScore: finalScore,\n                details: {\n                    listen_reasons: listenReasons,\n                    anti_patterns: antiPatternsDetected,\n                    recommendations: this.generateRecommendations(antiPatternsDetected)\n                }\n            };\n        } catch (error) {\n            return { finalScore: 0.7, error: error.message };\n        }\n    }\n    \n    extractListenReasons(candidateData) {\n        const reasons = candidateData.raisons_changement || candidateData.listen_reasons || [];\n        \n        if (typeof reasons === 'string') {\n            return [reasons];\n        }\n        \n        return Array.isArray(reasons) ? reasons : [];\n    }\n    \n    detectAntiPatterns(listenReasons, jobData, companyData) {\n        const detected = [];\n        \n        listenReasons.forEach(reason => {\n            const normalized = reason.toLowerCase();\n            \n            // D√©tection par mots-cl√©s\n            if (normalized.includes('distance') || normalized.includes('loin')) {\n                detected.push({ ...this.antiPatterns.distance_trop_importante, reason });\n            }\n            if (normalized.includes('salaire') || normalized.includes('r√©mun√©ration')) {\n                detected.push({ ...this.antiPatterns.salaire_insuffisant, reason });\n            }\n            if (normalized.includes('√©volution') || normalized.includes('carri√®re')) {\n                detected.push({ ...this.antiPatterns.manque_evolution, reason });\n            }\n            if (normalized.includes('environnement') || normalized.includes('ambiance')) {\n                detected.push({ ...this.antiPatterns.environnement_inadapte, reason });\n            }\n            if (normalized.includes('secteur') || normalized.includes('domaine')) {\n                detected.push({ ...this.antiPatterns.secteur_ininteressant, reason });\n            }\n        });\n        \n        return detected;\n    }\n    \n    generateRecommendations(antiPatterns) {\n        return antiPatterns.map(pattern => ({\n            issue: pattern.reason,\n            suggestion: pattern.suggestion,\n            action: pattern.action,\n            priority: pattern.severity\n        }));\n    }\n}\n\n/**\n * NEXTEN V2.0 - PROCESS POSITION MATCHER\n * Crit√®re #11 (2% du score) - Position process vs dur√©e\n * Algorithme d'optimisation du timing de recrutement\n */\n\nclass ProcessPositionMatcher {\n    constructor() {\n        this.weight = 0.02;\n        this.name = 'processPosition';\n        \n        // Stages du processus candidat\n        this.processStages = {\n            early: {\n                label: 'D√©but de recherche',\n                urgency: 'low',\n                flexibility: 'high',\n                process_tolerance: 'high'\n            },\n            active: {\n                label: 'Recherche active',\n                urgency: 'medium',\n                flexibility: 'medium',\n                process_tolerance: 'medium'\n            },\n            advanced: {\n                label: 'Processus avanc√©s',\n                urgency: 'high',\n                flexibility: 'low',\n                process_tolerance: 'low'\n            },\n            final: {\n                label: 'D√©cision imminente',\n                urgency: 'very_high',\n                flexibility: 'very_low',\n                process_tolerance: 'very_low'\n            }\n        };\n        \n        console.log('üìà ProcessPositionMatcher initialis√© - Crit√®re #11 (2%)');\n    }\n    \n    async calculateProcessPositionScore(candidateData, jobData, companyData = {}) {\n        try {\n            const candidateStage = this.extractCandidateProcessStage(candidateData);\n            const processLength = this.extractProcessLength(jobData, companyData);\n            \n            // Compatibilit√© timing\n            const timingCompatibility = this.calculateTimingCompatibility(candidateStage, processLength);\n            \n            // Urgence vs flexibilit√©\n            const urgencyMatch = this.calculateUrgencyMatch(candidateStage, processLength);\n            \n            const finalScore = (timingCompatibility + urgencyMatch) / 2;\n            \n            return {\n                finalScore: finalScore,\n                details: {\n                    candidate_stage: candidateStage,\n                    process_length: processLength,\n                    timing_compatibility: timingCompatibility,\n                    urgency_match: urgencyMatch\n                }\n            };\n        } catch (error) {\n            return { finalScore: 0.8, error: error.message };\n        }\n    }\n    \n    extractCandidateProcessStage(candidateData) {\n        const stage = candidateData.situation_process || candidateData.process_stage || 'active';\n        \n        const normalized = stage.toLowerCase();\n        if (normalized.includes('d√©but') || normalized.includes('early')) return 'early';\n        if (normalized.includes('avanc√©') || normalized.includes('advanced')) return 'advanced';\n        if (normalized.includes('final') || normalized.includes('d√©cision')) return 'final';\n        \n        return 'active'; // D√©faut\n    }\n    \n    extractProcessLength(jobData, companyData) {\n        const processInfo = jobData.processus_recrutement || jobData.process_duration || 'medium';\n        \n        const normalized = processInfo.toLowerCase();\n        if (normalized.includes('court') || normalized.includes('rapide')) {\n            return { type: 'short', weeks: 2 };\n        }\n        if (normalized.includes('long') || normalized.includes('complexe')) {\n            return { type: 'long', weeks: 8 };\n        }\n        \n        return { type: 'medium', weeks: 4 }; // D√©faut\n    }\n    \n    calculateTimingCompatibility(candidateStage, processLength) {\n        const stageData = this.processStages[candidateStage];\n        \n        // Candidats en fin de processus pr√©f√®rent des processus courts\n        if (candidateStage === 'final' && processLength.type === 'short') return 1.0;\n        if (candidateStage === 'final' && processLength.type === 'long') return 0.3;\n        \n        // Candidats en d√©but peuvent accepter des processus plus longs\n        if (candidateStage === 'early' && processLength.type === 'long') return 0.9;\n        if (candidateStage === 'early' && processLength.type === 'short') return 0.8;\n        \n        return 0.7; // Score moyen pour autres cas\n    }\n    \n    calculateUrgencyMatch(candidateStage, processLength) {\n        const stageData = this.processStages[candidateStage];\n        \n        // Match urgence candidat vs rapidit√© processus\n        if (stageData.urgency === 'very_high' && processLength.type === 'short') return 1.0;\n        if (stageData.urgency === 'low' && processLength.type === 'long') return 0.9;\n        \n        return 0.7;\n    }\n}\n\n// Exports pour int√©gration\nif (typeof module !== 'undefined' && module.exports) {\n    module.exports = {\n        AvailabilityMatcher,\n        ContractTypeMatcher,\n        ListenReasonsMatcher,\n        ProcessPositionMatcher\n    };\n}\n\nif (typeof window !== 'undefined') {\n    window.AvailabilityMatcher = AvailabilityMatcher;\n    window.ContractTypeMatcher = ContractTypeMatcher;\n    window.ListenReasonsMatcher = ListenReasonsMatcher;\n    window.ProcessPositionMatcher = ProcessPositionMatcher;\n    \n    console.log('‚è∞üìãüé≠üìà Crit√®res #8-11 disponibles (15% total)');\n}