#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
üöÄ SuperSmartMatch V2.1 - TESTS MASSIFS CORRIG√âS (213 matchings)
CORRECTION: Utilisation des vrais endpoints d√©couverts
"""

import os
import json
import requests
import time
from pathlib import Path
from datetime import datetime
import statistics

def test_all_cv_job_combinations():
    """Tests massifs : tous les CV contre tous les Jobs - ENDPOINTS CORRIG√âS"""
    print("üöÄ SUPERSMARTMATCH V2.1 - TESTS MASSIFS CORRIG√âS")
    print("=" * 60)
    print("üéØ Objectif: 71 CV √ó 3 Jobs = 213 matchings")
    print("üîß ENDPOINTS CORRIG√âS: /api/matching/enhanced")
    print()
    
    # Chemins des dossiers
    cv_dir = Path("/Users/baptistecomas/Desktop/CV TEST/")
    job_dir = Path("/Users/baptistecomas/Desktop/FDP TEST/")
    
    # V√©rifications pr√©liminaires
    if not cv_dir.exists():
        print(f"‚ùå Dossier CV non trouv√©: {cv_dir}")
        return False
    
    if not job_dir.exists():
        print(f"‚ùå Dossier Jobs non trouv√©: {job_dir}")
        return False
    
    # Lister tous les fichiers
    cv_files = list(cv_dir.glob("*.pdf"))
    job_files = list(job_dir.glob("*.pdf"))
    
    print(f"üìÑ CV trouv√©s: {len(cv_files)}")
    print(f"üíº Jobs trouv√©s: {len(job_files)}")
    print(f"üéØ Matchings √† tester: {len(cv_files) * len(job_files)}")
    print()
    
    if len(cv_files) == 0 or len(job_files) == 0:
        print("‚ùå Aucun fichier √† tester")
        return False
    
    # Test rapide de l'endpoint correct
    print("üîç Test de l'endpoint corrig√©...")
    test_success = test_correct_endpoint()
    if not test_success:
        print("‚ùå L'endpoint corrig√© ne fonctionne pas non plus")
        return False
    
    print("‚úÖ Endpoint corrig√© valid√© !")
    print()
    
    # Structures de donn√©es pour les r√©sultats
    results = []
    stats = {
        'total_tests': 0,
        'successful_tests': 0,
        'high_scores': 0,  # > 70%
        'medium_scores': 0,  # 40-70%
        'low_scores': 0,  # < 40%
        'errors': 0,
        'scores': [],
        'processing_times': []
    }
    
    print("üöÄ D√âBUT DES TESTS MASSIFS CORRIG√âS")
    print("=" * 40)
    
    start_time = time.time()
    
    # Tester seulement les 10 premiers CV pour commencer (test de validation)
    test_cv_files = cv_files[:10]  # Limiter pour valider d'abord
    
    # Tester chaque combinaison CV-Job
    for i, cv_file in enumerate(test_cv_files):
        print(f"\nüìÑ CV {i+1}/{len(test_cv_files)}: {cv_file.name[:50]}...")
        
        for j, job_file in enumerate(job_files):
            stats['total_tests'] += 1
            test_start = time.time()
            
            try:
                # Test du matching avec endpoint corrig√©
                result = test_cv_job_matching_corrected(cv_file, job_file)
                
                if result:
                    stats['successful_tests'] += 1
                    score = result['score']
                    stats['scores'].append(score)
                    
                    # Cat√©gorisation des scores
                    if score >= 70:
                        stats['high_scores'] += 1
                        status = "üü¢ EXCELLENT"
                    elif score >= 40:
                        stats['medium_scores'] += 1
                        status = "üü° MOYEN"
                    else:
                        stats['low_scores'] += 1
                        status = "üî¥ FAIBLE"
                    
                    processing_time = time.time() - test_start
                    stats['processing_times'].append(processing_time)
                    
                    # Affichage r√©sultat
                    job_name = job_file.name[:30]
                    print(f"   üíº {job_name}: {score}% {status}")
                    
                    # Stocker le r√©sultat
                    results.append({
                        'cv_file': cv_file.name,
                        'job_file': job_file.name,
                        'score': score,
                        'status': status,
                        'processing_time': processing_time,
                        'timestamp': datetime.now().isoformat(),
                        'details': result
                    })
                    
                else:
                    stats['errors'] += 1
                    print(f"   ‚ùå {job_file.name[:30]}: ERREUR")
                    
            except Exception as e:
                stats['errors'] += 1
                print(f"   ‚ùå {job_file.name[:30]}: {str(e)[:50]}...")
    
    # Calcul des statistiques finales
    total_time = time.time() - start_time
    
    print("\n" + "=" * 60)
    print("üìä R√âSULTATS TESTS CORRIG√âS (√âCHANTILLON)")
    print("=" * 60)
    
    print(f"‚è±Ô∏è Temps total: {total_time:.1f} secondes")
    print(f"üìä Tests r√©alis√©s: {stats['total_tests']}")
    print(f"‚úÖ Tests r√©ussis: {stats['successful_tests']} ({stats['successful_tests']/stats['total_tests']*100:.1f}%)")
    print(f"‚ùå Erreurs: {stats['errors']}")
    
    if stats['scores']:
        avg_score = statistics.mean(stats['scores'])
        median_score = statistics.median(stats['scores'])
        max_score = max(stats['scores'])
        min_score = min(stats['scores'])
        
        print(f"\nüéØ ANALYSE DES SCORES:")
        print(f"   üìà Score moyen: {avg_score:.1f}%")
        print(f"   üìä Score m√©dian: {median_score:.1f}%")
        print(f"   ‚¨ÜÔ∏è Score max: {max_score:.1f}%")
        print(f"   ‚¨áÔ∏è Score min: {min_score:.1f}%")
        
        print(f"\nüìä DISTRIBUTION DES SCORES:")
        print(f"   üü¢ Excellents (‚â•70%): {stats['high_scores']} ({stats['high_scores']/len(stats['scores'])*100:.1f}%)")
        print(f"   üü° Moyens (40-69%): {stats['medium_scores']} ({stats['medium_scores']/len(stats['scores'])*100:.1f}%)")
        print(f"   üî¥ Faibles (<40%): {stats['low_scores']} ({stats['low_scores']/len(stats['scores'])*100:.1f}%)")
    
    # G√©n√©rer rapport d√©taill√©
    report_filename = f"corrected_test_report_{datetime.now().strftime('%Y%m%d_%H%M%S')}.json"
    
    final_report = {
        'test_info': {
            'total_cv_tested': len(test_cv_files),
            'total_jobs': len(job_files),
            'total_combinations': len(test_cv_files) * len(job_files),
            'test_duration': total_time,
            'endpoint_used': '/api/matching/enhanced',
            'timestamp': datetime.now().isoformat()
        },
        'statistics': stats,
        'detailed_results': results
    }
    
    with open(report_filename, 'w', encoding='utf-8') as f:
        json.dump(final_report, f, indent=2, ensure_ascii=False)
    
    print(f"\nüìã Rapport d√©taill√©: {report_filename}")
    
    # Validation du succ√®s
    success_rate = stats['successful_tests'] / stats['total_tests']
    
    if success_rate > 0.8:
        print(f"\nüéâ SUCC√àS ! Endpoint corrig√© fonctionne")
        print(f"‚úÖ Taux de succ√®s: {success_rate*100:.1f}%")
        print(f"\nüöÄ PR√äT POUR LES 213 TESTS COMPLETS!")
        print(f"üí° Modifier le script pour tester tous les CV (retirer [:10])")
        return True
    else:
        print(f"\n‚ö†Ô∏è Taux de succ√®s faible: {success_rate*100:.1f}%")
        print(f"üí° V√©rifier les erreurs restantes")
        return False

def test_correct_endpoint():
    """Test rapide de l'endpoint corrig√©"""
    try:
        # Test simple avec Hugo Salvat
        cv_file = Path("/Users/baptistecomas/Desktop/CV TEST/SALVAT Hugo_CV.pdf")
        job_file = list(Path("/Users/baptistecomas/Desktop/FDP TEST/").glob("*.pdf"))[0]
        
        # Parser CV et Job
        cv_data = parse_cv(cv_file)
        job_data = parse_job(job_file)
        
        if not cv_data or not job_data:
            return False
        
        # Test de l'endpoint corrig√©
        result = calculate_matching_corrected(cv_data, job_data)
        return result is not None
        
    except Exception:
        return False

def test_cv_job_matching_corrected(cv_file, job_file):
    """Test d'un matching CV-Job avec endpoint corrig√©"""
    try:
        # Parser le CV
        cv_data = parse_cv(cv_file)
        if not cv_data:
            return None
        
        # Parser le Job
        job_data = parse_job(job_file)
        if not job_data:
            return None
        
        # Calculer le matching avec endpoint corrig√©
        matching_result = calculate_matching_corrected(cv_data, job_data)
        
        return matching_result
        
    except Exception as e:
        return None

def parse_cv(cv_file):
    """Parser un CV via l'API"""
    try:
        with open(cv_file, 'rb') as f:
            files = {'file': (cv_file.name, f, 'application/pdf')}
            response = requests.post(
                "http://localhost:5051/api/parse-cv",
                files=files,
                timeout=30
            )
        
        if response.status_code == 200:
            return response.json().get('data', {})
        else:
            return None
            
    except Exception:
        return None

def parse_job(job_file):
    """Parser un Job via l'API"""
    try:
        with open(job_file, 'rb') as f:
            files = {'file': (job_file.name, f, 'application/pdf')}
            response = requests.post(
                "http://localhost:5053/api/parse-job",
                files=files,
                timeout=30
            )
        
        if response.status_code == 200:
            return response.json().get('data', {})
        else:
            return None
            
    except Exception:
        return None

def calculate_matching_corrected(cv_data, job_data):
    """Calculer le matching via l'Enhanced API avec endpoint corrig√©"""
    try:
        payload = {
            "cv_data": cv_data,
            "job_data": job_data
        }
        
        # ENDPOINT CORRIG√â: /api/matching/enhanced
        response = requests.post(
            "http://localhost:5055/api/matching/enhanced",
            json=payload,
            timeout=15
        )
        
        if response.status_code == 200:
            result = response.json()
            return {
                'score': result.get('matching_score', result.get('score', 0)),
                'confidence': result.get('confidence', 'low'),
                'recommendation': result.get('recommendation', ''),
                'details': result.get('details', {})
            }
        else:
            # Si enhanced ne marche pas, essayer complete
            response = requests.post(
                "http://localhost:5055/api/matching/complete",
                json=payload,
                timeout=15
            )
            
            if response.status_code == 200:
                result = response.json()
                return {
                    'score': result.get('matching_score', result.get('score', 0)),
                    'confidence': result.get('confidence', 'low'),
                    'recommendation': result.get('recommendation', ''),
                    'details': result.get('details', {})
                }
            else:
                return None
            
    except Exception:
        return None

def main():
    """Fonction principale"""
    print("üéØ TESTS MASSIFS AVEC ENDPOINTS CORRIG√âS")
    print("Correction bas√©e sur le diagnostic Enhanced API")
    print()
    
    # V√©rification des services
    services = {
        "CV Parser V2": "http://localhost:5051/health",
        "Job Parser V2": "http://localhost:5053/health",
        "Enhanced API V2.1": "http://localhost:5055/health"
    }
    
    print("üîç V√©rification des services...")
    all_services_ok = True
    
    for service, url in services.items():
        try:
            response = requests.get(url, timeout=5)
            if response.status_code == 200:
                print(f"   ‚úÖ {service}: OP√âRATIONNEL")
            else:
                print(f"   ‚ùå {service}: ERREUR {response.status_code}")
                all_services_ok = False
        except Exception as e:
            print(f"   ‚ùå {service}: INACCESSIBLE")
            all_services_ok = False
    
    if not all_services_ok:
        print("\n‚ùå Certains services ne sont pas disponibles.")
        return False
    
    print("\n‚úÖ Tous les services sont op√©rationnels!")
    print()
    
    # Lancer les tests corrig√©s
    return test_all_cv_job_combinations()

if __name__ == "__main__":
    main()
