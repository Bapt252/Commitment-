# SuperSmartMatch V2 - CI/CD Pipeline Configuration

## üöÄ Overview CI/CD Architecture

Pipeline automatis√© GitHub Actions avec d√©ploiement multi-environnements, tests de s√©curit√©, et strat√©gies de d√©ploiement avanc√©es.

### üèóÔ∏è Pipeline Architecture

```mermaid
graph TB
    subgraph "üîÑ CI/CD Pipeline"
        COMMIT[Git Commit/PR]
        
        subgraph "üß™ Continuous Integration"
            BUILD[Build & Test]
            SECURITY[Security Scan]
            QUALITY[Quality Gate]
        end
        
        subgraph "üì¶ Artifact Management"
            DOCKER[Docker Build]
            REGISTRY[Container Registry]
            HELM[Helm Package]
        end
        
        subgraph "üöÄ Continuous Deployment"
            DEV_DEPLOY[Deploy Dev]
            STAGING_DEPLOY[Deploy Staging]
            PROD_DEPLOY[Deploy Production]
        end
        
        subgraph "‚úÖ Validation"
            SMOKE_TESTS[Smoke Tests]
            INTEGRATION[Integration Tests]
            PERFORMANCE[Performance Tests]
        end
    end
    
    COMMIT --> BUILD
    BUILD --> SECURITY
    SECURITY --> QUALITY
    
    QUALITY --> DOCKER
    DOCKER --> REGISTRY
    REGISTRY --> HELM
    
    HELM --> DEV_DEPLOY
    DEV_DEPLOY --> SMOKE_TESTS
    SMOKE_TESTS --> STAGING_DEPLOY
    STAGING_DEPLOY --> INTEGRATION
    INTEGRATION --> PROD_DEPLOY
    PROD_DEPLOY --> PERFORMANCE
```

---

## 1. üèóÔ∏è Main CI/CD Workflow

### GitHub Actions Workflow (.github/workflows/cicd.yml)

```yaml
name: SuperSmartMatch V2 - CI/CD Pipeline

on:
  push:
    branches: [main, develop, feature/supersmartmatch-v2-architecture]
    paths-ignore:
      - '**.md'
      - 'docs/**'
  pull_request:
    branches: [main, develop]
    paths-ignore:
      - '**.md'
      - 'docs/**'
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy'
        required: true
        default: 'dev'
        type: choice
        options: ['dev', 'staging', 'prod']
      force_deploy:
        description: 'Force deployment (skip tests)'
        required: false
        default: false
        type: boolean

env:
  REGISTRY: ghcr.io
  AWS_REGION: eu-west-1
  TERRAFORM_VERSION: 1.6.6
  KUBECTL_VERSION: 1.28.4
  HELM_VERSION: 3.13.3

permissions:
  contents: read
  packages: write
  security-events: write
  id-token: write

jobs:
  # ================================
  # SETUP AND VALIDATION
  # ================================
  
  setup:
    name: üîß Setup and Validation
    runs-on: ubuntu-latest
    outputs:
      should_deploy: ${{ steps.conditions.outputs.should_deploy }}
      environment: ${{ steps.conditions.outputs.environment }}
      version: ${{ steps.version.outputs.version }}
      services_changed: ${{ steps.changes.outputs.services }}
      infrastructure_changed: ${{ steps.changes.outputs.infrastructure }}
    
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
      
      - name: Check Changes
        id: changes
        uses: dorny/paths-filter@v2
        with:
          filters: |
            services:
              - 'services/**'
              - 'helm-charts/**'
              - 'Dockerfile*'
            infrastructure:
              - 'terraform/**'
              - 'architecture-v2/**'
            
      - name: Determine Deployment Conditions
        id: conditions
        run: |
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            echo "should_deploy=true" >> $GITHUB_OUTPUT
            echo "environment=${{ github.event.inputs.environment }}" >> $GITHUB_OUTPUT
          elif [[ "${{ github.ref }}" == "refs/heads/main" ]]; then
            echo "should_deploy=true" >> $GITHUB_OUTPUT
            echo "environment=prod" >> $GITHUB_OUTPUT
          elif [[ "${{ github.ref }}" == "refs/heads/develop" ]]; then
            echo "should_deploy=true" >> $GITHUB_OUTPUT
            echo "environment=staging" >> $GITHUB_OUTPUT
          elif [[ "${{ github.ref }}" == "refs/heads/feature/supersmartmatch-v2-architecture" ]]; then
            echo "should_deploy=true" >> $GITHUB_OUTPUT
            echo "environment=dev" >> $GITHUB_OUTPUT
          else
            echo "should_deploy=false" >> $GITHUB_OUTPUT
            echo "environment=dev" >> $GITHUB_OUTPUT
          fi
      
      - name: Generate Version
        id: version
        run: |
          if [[ "${{ github.event_name }}" == "push" ]]; then
            VERSION="v2.$(date +%Y%m%d).${GITHUB_SHA:0:7}"
          else
            VERSION="v2.pr-${{ github.event.number }}.${GITHUB_SHA:0:7}"
          fi
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "Version: $VERSION"

  # ================================
  # CODE QUALITY AND SECURITY
  # ================================
  
  code_quality:
    name: üîç Code Quality & Security
    runs-on: ubuntu-latest
    needs: setup
    if: ${{ !github.event.inputs.force_deploy }}
    
    services:
      postgres:
        image: postgres:15
        env:
          POSTGRES_PASSWORD: postgres
          POSTGRES_DB: test_db
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 5432:5432
      
      redis:
        image: redis:7-alpine
        options: >-
          --health-cmd "redis-cli ping"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 6379:6379
    
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4
      
      - name: Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'
          cache: 'pip'
      
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
          cache: 'npm'
      
      - name: Install Dependencies
        run: |
          # Python dependencies
          pip install -r requirements.txt
          pip install -r requirements-dev.txt
          
          # Node.js dependencies
          npm ci
      
      - name: Run Linting
        run: |
          # Python linting
          flake8 . --count --select=E9,F63,F7,F82 --show-source --statistics
          black --check .
          isort --check-only .
          
          # JavaScript/TypeScript linting
          npm run lint
          
          # Terraform linting
          terraform fmt -check -recursive terraform/
      
      - name: Run Unit Tests
        run: |
          # Python tests
          pytest tests/unit/ --cov=. --cov-report=xml --cov-report=html
          
          # JavaScript tests
          npm run test:unit
        env:
          DATABASE_URL: postgresql://postgres:postgres@localhost:5432/test_db
          REDIS_URL: redis://localhost:6379/0
      
      - name: SonarCloud Scan
        uses: SonarSource/sonarcloud-github-action@master
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
      
      - name: CodeQL Analysis
        uses: github/codeql-action/init@v3
        with:
          languages: python, javascript
      
      - name: Perform CodeQL Analysis
        uses: github/codeql-action/analyze@v3
      
      - name: Security Scan - Bandit
        run: |
          bandit -r . -f json -o bandit-report.json || true
      
      - name: Security Scan - Safety
        run: |
          safety check --json --output safety-report.json || true
      
      - name: Security Scan - Semgrep
        uses: returntocorp/semgrep-action@v1
        with:
          config: >-
            p/security-audit
            p/secrets
            p/owasp-top-ten
      
      - name: Upload Test Results
        uses: actions/upload-artifact@v3
        if: always()
        with:
          name: test-results
          path: |
            coverage.xml
            htmlcov/
            bandit-report.json
            safety-report.json

  # ================================
  # DOCKER BUILD AND PUSH
  # ================================
  
  build_images:
    name: üê≥ Build Docker Images
    runs-on: ubuntu-latest
    needs: [setup, code_quality]
    if: ${{ needs.setup.outputs.services_changed == 'true' || github.event.inputs.force_deploy }}
    
    strategy:
      matrix:
        service:
          - api-gateway
          - scoring-engine
          - geolocation-service
          - temporal-service
          - behavior-service
          - explainer-service
          - analytics-service
    
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4
      
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
      
      - name: Log in to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}
      
      - name: Extract Metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ github.repository_owner }}/supersmartmatch-${{ matrix.service }}
          tags: |
            type=ref,event=branch
            type=ref,event=pr
            type=sha,prefix={{branch}}-
            type=raw,value=${{ needs.setup.outputs.version }}
      
      - name: Build and Push Docker Image
        uses: docker/build-push-action@v5
        with:
          context: ./services/${{ matrix.service }}
          file: ./services/${{ matrix.service }}/Dockerfile
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          platforms: linux/amd64,linux/arm64
          build-args: |
            VERSION=${{ needs.setup.outputs.version }}
            BUILD_DATE=${{ github.event.head_commit.timestamp }}
            GIT_COMMIT=${{ github.sha }}

  # ================================
  # INFRASTRUCTURE DEPLOYMENT
  # ================================
  
  deploy_infrastructure:
    name: üèóÔ∏è Deploy Infrastructure
    runs-on: ubuntu-latest
    needs: [setup]
    if: ${{ needs.setup.outputs.should_deploy == 'true' && needs.setup.outputs.infrastructure_changed == 'true' }}
    environment: ${{ needs.setup.outputs.environment }}
    
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4
      
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}
      
      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TERRAFORM_VERSION }}
      
      - name: Terraform Format Check
        run: terraform fmt -check -recursive
        working-directory: terraform/
      
      - name: Terraform Init
        run: |
          terraform init \
            -backend-config="bucket=supersmartmatch-terraform-state-${{ needs.setup.outputs.environment }}" \
            -backend-config="key=${{ needs.setup.outputs.environment }}/terraform.tfstate"
        working-directory: terraform/environments/${{ needs.setup.outputs.environment }}/
      
      - name: Terraform Plan
        id: plan
        run: |
          terraform plan \
            -var-file="terraform.tfvars" \
            -var="environment=${{ needs.setup.outputs.environment }}" \
            -out=tfplan \
            -detailed-exitcode
        working-directory: terraform/environments/${{ needs.setup.outputs.environment }}/
        continue-on-error: true
      
      - name: Comment PR with Plan
        if: github.event_name == 'pull_request'
        uses: actions/github-script@v7
        with:
          script: |
            const output = `
            #### Terraform Plan üìñ \`${{ steps.plan.outcome }}\`
            
            <details><summary>Show Plan</summary>
            
            \`\`\`terraform
            ${{ steps.plan.outputs.stdout }}
            \`\`\`
            
            </details>
            
            *Pusher: @${{ github.actor }}, Action: \`${{ github.event_name }}\`*
            `;
            
            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: output
            })
      
      - name: Terraform Apply
        if: steps.plan.outputs.exitcode == 2 && github.event_name != 'pull_request'
        run: terraform apply tfplan
        working-directory: terraform/environments/${{ needs.setup.outputs.environment }}/
        
      - name: Save Terraform Outputs
        if: github.event_name != 'pull_request'
        run: |
          terraform output -json > terraform-outputs.json
          echo "CLUSTER_NAME=$(terraform output -raw cluster_name)" >> $GITHUB_ENV
          echo "CLUSTER_ENDPOINT=$(terraform output -raw cluster_endpoint)" >> $GITHUB_ENV
        working-directory: terraform/environments/${{ needs.setup.outputs.environment }}/
      
      - name: Upload Terraform Outputs
        if: github.event_name != 'pull_request'
        uses: actions/upload-artifact@v3
        with:
          name: terraform-outputs-${{ needs.setup.outputs.environment }}
          path: terraform/environments/${{ needs.setup.outputs.environment }}/terraform-outputs.json

  # ================================
  # APPLICATION DEPLOYMENT
  # ================================
  
  deploy_application:
    name: üöÄ Deploy Application
    runs-on: ubuntu-latest
    needs: [setup, build_images, deploy_infrastructure]
    if: ${{ always() && needs.setup.outputs.should_deploy == 'true' && (needs.build_images.result == 'success' || needs.build_images.result == 'skipped') }}
    environment: ${{ needs.setup.outputs.environment }}
    
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4
      
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}
      
      - name: Setup kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: ${{ env.KUBECTL_VERSION }}
      
      - name: Setup Helm
        uses: azure/setup-helm@v3
        with:
          version: ${{ env.HELM_VERSION }}
      
      - name: Download Terraform Outputs
        uses: actions/download-artifact@v3
        with:
          name: terraform-outputs-${{ needs.setup.outputs.environment }}
          path: ./
      
      - name: Configure kubectl
        run: |
          CLUSTER_NAME=$(jq -r '.cluster_name.value' terraform-outputs.json)
          aws eks update-kubeconfig --region ${{ env.AWS_REGION }} --name $CLUSTER_NAME
      
      - name: Deploy with Helm
        run: |
          # Add Helm repositories
          helm repo add bitnami https://charts.bitnami.com/bitnami
          helm repo add prometheus-community https://prometheus-community.github.io/helm-charts
          helm repo add elastic https://helm.elastic.co
          helm repo update
          
          # Deploy application
          helm upgrade --install supersmartmatch-v2 ./helm-charts/supersmartmatch-v2 \
            --namespace supersmartmatch \
            --create-namespace \
            --values ./helm-charts/supersmartmatch-v2/values-${{ needs.setup.outputs.environment }}.yaml \
            --set global.version=${{ needs.setup.outputs.version }} \
            --set global.environment=${{ needs.setup.outputs.environment }} \
            --set global.registry=${{ env.REGISTRY }} \
            --set global.repository=${{ github.repository_owner }} \
            --wait \
            --timeout=600s
      
      - name: Verify Deployment
        run: |
          # Wait for rollout to complete
          kubectl rollout status deployment/supersmartmatch-api-gateway -n supersmartmatch --timeout=300s
          kubectl rollout status deployment/supersmartmatch-scoring-engine -n supersmartmatch --timeout=300s
          
          # Check pod status
          kubectl get pods -n supersmartmatch
          
          # Check service endpoints
          kubectl get services -n supersmartmatch

  # ================================
  # INTEGRATION TESTS
  # ================================
  
  integration_tests:
    name: üß™ Integration Tests
    runs-on: ubuntu-latest
    needs: [setup, deploy_application]
    if: ${{ always() && needs.deploy_application.result == 'success' }}
    environment: ${{ needs.setup.outputs.environment }}
    
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4
      
      - name: Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'
      
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}
      
      - name: Setup kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: ${{ env.KUBECTL_VERSION }}
      
      - name: Download Terraform Outputs
        uses: actions/download-artifact@v3
        with:
          name: terraform-outputs-${{ needs.setup.outputs.environment }}
          path: ./
      
      - name: Configure kubectl
        run: |
          CLUSTER_NAME=$(jq -r '.cluster_name.value' terraform-outputs.json)
          aws eks update-kubeconfig --region ${{ env.AWS_REGION }} --name $CLUSTER_NAME
      
      - name: Wait for Services
        run: |
          # Wait for all services to be ready
          kubectl wait --for=condition=ready pod -l app=supersmartmatch-api-gateway -n supersmartmatch --timeout=300s
          kubectl wait --for=condition=ready pod -l app=supersmartmatch-scoring-engine -n supersmartmatch --timeout=300s
      
      - name: Run Smoke Tests
        run: |
          python -m pytest tests/smoke/ -v --tb=short
        env:
          API_BASE_URL: ${{ secrets.API_BASE_URL }}
          TEST_USER_EMAIL: ${{ secrets.TEST_USER_EMAIL }}
          TEST_USER_PASSWORD: ${{ secrets.TEST_USER_PASSWORD }}
      
      - name: Run Integration Tests
        if: needs.setup.outputs.environment != 'prod'
        run: |
          python -m pytest tests/integration/ -v --tb=short
        env:
          API_BASE_URL: ${{ secrets.API_BASE_URL }}
          DATABASE_URL: ${{ secrets.DATABASE_URL }}
          REDIS_URL: ${{ secrets.REDIS_URL }}
      
      - name: Performance Tests
        if: needs.setup.outputs.environment == 'staging'
        run: |
          # Load testing with locust
          pip install locust
          locust -f tests/performance/locustfile.py --headless -u 50 -r 10 -t 5m --host=${{ secrets.API_BASE_URL }}
      
      - name: Upload Test Results
        uses: actions/upload-artifact@v3
        if: always()
        with:
          name: integration-test-results-${{ needs.setup.outputs.environment }}
          path: |
            test-results/
            screenshots/

  # ================================
  # SECURITY TESTS
  # ================================
  
  security_tests:
    name: üîí Security Tests
    runs-on: ubuntu-latest
    needs: [setup, deploy_application]
    if: ${{ always() && needs.deploy_application.result == 'success' && needs.setup.outputs.environment != 'prod' }}
    environment: ${{ needs.setup.outputs.environment }}
    
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4
      
      - name: OWASP ZAP Scan
        uses: zaproxy/action-baseline@v0.10.0
        with:
          target: ${{ secrets.API_BASE_URL }}
          rules_file_name: '.zap/rules.tsv'
          cmd_options: '-a'
      
      - name: Nuclei Scan
        uses: projectdiscovery/nuclei-action@main
        with:
          target: ${{ secrets.API_BASE_URL }}
          github-report: true
          github-token: ${{ secrets.GITHUB_TOKEN }}
      
      - name: Container Security Scan
        run: |
          # Scan deployed containers for vulnerabilities
          kubectl get pods -n supersmartmatch -o jsonpath='{.items[*].spec.containers[*].image}' | \
          xargs -n 1 docker run --rm -v /var/run/docker.sock:/var/run/docker.sock \
          aquasec/trivy image --format json --output trivy-report.json

  # ================================
  # ROLLBACK ON FAILURE
  # ================================
  
  rollback:
    name: üîÑ Rollback on Failure
    runs-on: ubuntu-latest
    needs: [setup, deploy_application, integration_tests]
    if: ${{ always() && (needs.deploy_application.result == 'failure' || needs.integration_tests.result == 'failure') && needs.setup.outputs.environment == 'prod' }}
    environment: production
    
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4
      
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}
      
      - name: Setup Helm
        uses: azure/setup-helm@v3
        with:
          version: ${{ env.HELM_VERSION }}
      
      - name: Rollback Deployment
        run: |
          helm rollback supersmartmatch-v2 --namespace supersmartmatch
      
      - name: Notify Failure
        uses: 8398a7/action-slack@v3
        with:
          status: failure
          channel: '#alerts'
          text: |
            üö® SuperSmartMatch V2 deployment failed and was rolled back!
            Environment: ${{ needs.setup.outputs.environment }}
            Version: ${{ needs.setup.outputs.version }}
            Commit: ${{ github.sha }}
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}

  # ================================
  # NOTIFICATIONS
  # ================================
  
  notify:
    name: üì¢ Notify Results
    runs-on: ubuntu-latest
    needs: [setup, code_quality, build_images, deploy_infrastructure, deploy_application, integration_tests, security_tests]
    if: always()
    
    steps:
      - name: Determine Status
        id: status
        run: |
          if [[ "${{ needs.deploy_application.result }}" == "success" && "${{ needs.integration_tests.result }}" == "success" ]]; then
            echo "status=success" >> $GITHUB_OUTPUT
            echo "message=‚úÖ Deployment successful!" >> $GITHUB_OUTPUT
          elif [[ "${{ needs.deploy_application.result }}" == "failure" || "${{ needs.integration_tests.result }}" == "failure" ]]; then
            echo "status=failure" >> $GITHUB_OUTPUT
            echo "message=‚ùå Deployment failed!" >> $GITHUB_OUTPUT
          else
            echo "status=partial" >> $GITHUB_OUTPUT
            echo "message=‚ö†Ô∏è Deployment completed with warnings" >> $GITHUB_OUTPUT
          fi
      
      - name: Slack Notification
        uses: 8398a7/action-slack@v3
        with:
          status: ${{ steps.status.outputs.status }}
          channel: '#deployments'
          text: |
            ${{ steps.status.outputs.message }}
            
            **SuperSmartMatch V2 Deployment**
            Environment: `${{ needs.setup.outputs.environment }}`
            Version: `${{ needs.setup.outputs.version }}`
            Commit: `${{ github.sha }}`
            Actor: `${{ github.actor }}`
            
            **Results:**
            ‚Ä¢ Code Quality: ${{ needs.code_quality.result }}
            ‚Ä¢ Build Images: ${{ needs.build_images.result }}
            ‚Ä¢ Infrastructure: ${{ needs.deploy_infrastructure.result }}
            ‚Ä¢ Application: ${{ needs.deploy_application.result }}
            ‚Ä¢ Integration Tests: ${{ needs.integration_tests.result }}
            ‚Ä¢ Security Tests: ${{ needs.security_tests.result }}
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
      
      - name: Email Notification
        if: needs.setup.outputs.environment == 'prod'
        uses: dawidd6/action-send-mail@v3
        with:
          server_address: ${{ secrets.SMTP_HOST }}
          server_port: 587
          username: ${{ secrets.SMTP_USERNAME }}
          password: ${{ secrets.SMTP_PASSWORD }}
          subject: SuperSmartMatch V2 - Production Deployment ${{ steps.status.outputs.status }}
          to: ${{ secrets.DEPLOYMENT_EMAIL_LIST }}
          from: SuperSmartMatch CI/CD <noreply@supersmartmatch.com>
          html_body: |
            <h2>SuperSmartMatch V2 Production Deployment</h2>
            <p><strong>Status:</strong> ${{ steps.status.outputs.message }}</p>
            <p><strong>Version:</strong> ${{ needs.setup.outputs.version }}</p>
            <p><strong>Environment:</strong> ${{ needs.setup.outputs.environment }}</p>
            <p><strong>Commit:</strong> ${{ github.sha }}</p>
            <p><strong>Deployed by:</strong> ${{ github.actor }}</p>
            <hr>
            <h3>Pipeline Results:</h3>
            <ul>
              <li>Code Quality: ${{ needs.code_quality.result }}</li>
              <li>Build Images: ${{ needs.build_images.result }}</li>
              <li>Infrastructure: ${{ needs.deploy_infrastructure.result }}</li>
              <li>Application: ${{ needs.deploy_application.result }}</li>
              <li>Integration Tests: ${{ needs.integration_tests.result }}</li>
              <li>Security Tests: ${{ needs.security_tests.result }}</li>
            </ul>
```

Cette pipeline CI/CD GitHub Actions fournit :

‚úÖ **Multi-environnements** : Dev, staging, production avec conditions  
‚úÖ **Tests complets** : Unit, integration, s√©curit√©, performance  
‚úÖ **S√©curit√©** : SAST, DAST, scan containers, secrets management  
‚úÖ **D√©ploiement automatis√©** : Infrastructure + applications avec Helm  
‚úÖ **Monitoring** : Tests de fum√©e et validation post-d√©ploiement  
‚úÖ **Rollback automatique** : En cas d'√©chec en production  
‚úÖ **Notifications** : Slack, email, GitHub PR comments  

La suite : configuration du monitoring et observabilit√© !
