const fs = require('fs');
const pdf = require('pdf-parse');
const path = require('path');

// Chemin vers ton PDF de test
const PDF_PATH = path.join(require('os').homedir(), 'Desktop', 'Bcom HR Opportunit√© de poste Assistant Juridique.pdf');

console.log('üîç TEST EXTRACTION TITRE - JobParserAPI');
console.log('=====================================');
console.log(`üìÅ PDF Test: ${PDF_PATH}`);

// Strat√©gie 1: Pattern exact pour "Assistant juridique"
function extractTitleByPattern(text) {
    console.log('\nüìã STRAT√âGIE 1: Pattern exact');
    console.log('------------------------------');
    
    const patterns = [
        /Assistant(?:\(e\))?\s+juridique/i,
        /Assistant(?:e)?\s+juridique/i,
        /Juriste/i,
        /Conseiller(?:\(√®re\))?\s+juridique/i
    ];
    
    for (const pattern of patterns) {
        const match = text.match(pattern);
        if (match) {
            const title = match[0].trim();
            console.log(`‚úÖ Pattern trouv√©: "${title}"`);
            console.log(`üìè Longueur: ${title.length} caract√®res`);
            return title.length <= 25 ? title : title.substring(0, 25);
        }
    }
    
    console.log('‚ùå Aucun pattern trouv√©');
    return 'Poste √† pourvoir';
}

// Strat√©gie 2: Premi√®re ligne intelligente
function extractTitleByFirstLine(text) {
    console.log('\nüìã STRAT√âGIE 2: Premi√®re ligne intelligente');
    console.log('------------------------------------------');
    
    const lines = text.split('\n').map(line => line.trim()).filter(line => line.length > 0);
    
    for (let i = 0; i < Math.min(5, lines.length); i++) {
        const line = lines[i];
        console.log(`Ligne ${i + 1}: "${line.substring(0, 50)}${line.length > 50 ? '...' : ''}"`);
        
        // Ignorer les lignes trop courtes ou avec des mots-cl√©s non pertinents
        if (line.length < 5 || 
            /^(qui sommes|nous|offre|poste|opportunit√©|recrutement)/i.test(line)) {
            console.log(`  ‚è≠Ô∏è Ignor√©e (${line.length < 5 ? 'trop courte' : 'mot-cl√© non pertinent'})`);
            continue;
        }
        
        // Nettoyer la ligne
        let cleanTitle = line
            .replace(/^[^a-zA-Z√Ä-√ø]*/, '') // Supprimer caract√®res non alphab√©tiques au d√©but
            .replace(/[^\w\s√Ä-√ø\(\)]+.*$/, '') // Supprimer tout apr√®s caract√®res sp√©ciaux
            .trim();
        
        if (cleanTitle.length >= 5 && cleanTitle.length <= 50) {
            const finalTitle = cleanTitle.length <= 25 ? cleanTitle : cleanTitle.substring(0, 25);
            console.log(`‚úÖ Titre extrait: "${finalTitle}"`);
            console.log(`üìè Longueur: ${finalTitle.length} caract√®res`);
            return finalTitle;
        }
    }
    
    console.log('‚ùå Aucune premi√®re ligne valide trouv√©e');
    return 'Poste √† pourvoir';
}

// Strat√©gie 3: D√©tection par mots-cl√©s professionnels
function extractTitleByKeywords(text) {
    console.log('\nüìã STRAT√âGIE 3: Mots-cl√©s professionnels');
    console.log('---------------------------------------');
    
    const jobKeywords = {
        'Assistant juridique': ['assistant juridique', 'assistante juridique', 'assistant(e) juridique'],
        'Juriste': ['juriste', 'juriste d\'entreprise', 'juriste contrats'],
        'Conseiller juridique': ['conseiller juridique', 'conseill√®re juridique', 'conseiller(√®re) juridique'],
        'Responsable juridique': ['responsable juridique', 'responsable affaires juridiques'],
        'Secr√©taire juridique': ['secr√©taire juridique']
    };
    
    // Normaliser le texte pour la recherche
    const normalizedText = text.toLowerCase().replace(/[√†√°√¢√£√§√•]/g, 'a').replace(/[√®√©√™√´]/g, 'e');
    
    for (const [jobTitle, keywords] of Object.entries(jobKeywords)) {
        for (const keyword of keywords) {
            if (normalizedText.includes(keyword.toLowerCase())) {
                console.log(`‚úÖ Mot-cl√© trouv√©: "${keyword}" ‚Üí "${jobTitle}"`);
                console.log(`üìè Longueur: ${jobTitle.length} caract√®res`);
                return jobTitle;
            }
        }
    }
    
    // Recherche g√©n√©rique de mots professionnels
    const genericPatterns = [
        /\b(assistant|assistante|secr√©taire|conseiller|conseill√®re|responsable|chef|manager|directeur|directrice)\s+\w+/gi
    ];
    
    for (const pattern of genericPatterns) {
        const matches = text.match(pattern);
        if (matches && matches.length > 0) {
            const title = matches[0].trim();
            const finalTitle = title.length <= 25 ? title : title.substring(0, 25);
            console.log(`‚úÖ Pattern g√©n√©rique trouv√©: "${finalTitle}"`);
            console.log(`üìè Longueur: ${finalTitle.length} caract√®res`);
            return finalTitle;
        }
    }
    
    console.log('‚ùå Aucun mot-cl√© professionnel trouv√©');
    return 'Poste √† pourvoir';
}

// Strat√©gie 4: Multi-patterns avec fallback
function extractTitleMultiPatterns(text) {
    console.log('\nüìã STRAT√âGIE 4: Multi-patterns avec fallback');
    console.log('--------------------------------------------');
    
    // √âtape 1: Patterns sp√©cifiques haute priorit√©
    const highPriorityPatterns = [
        { regex: /Assistant(?:\(e\))?\s+juridique/i, name: 'Assistant juridique sp√©cifique' },
        { regex: /Juriste(?:\s+[a-zA-Z√Ä-√ø]+)?/i, name: 'Juriste g√©n√©ral' },
        { regex: /Conseiller(?:\(√®re\))?\s+juridique/i, name: 'Conseiller juridique' }
    ];
    
    console.log('üéØ Test patterns haute priorit√©:');
    for (const { regex, name } of highPriorityPatterns) {
        const match = text.match(regex);
        if (match) {
            const title = match[0].trim();
            const finalTitle = title.length <= 25 ? title : title.substring(0, 25);
            console.log(`  ‚úÖ ${name}: "${finalTitle}" (${finalTitle.length} caract√®res)`);
            return finalTitle;
        }
        console.log(`  ‚ùå ${name}: Non trouv√©`);
    }
    
    // √âtape 2: Analyse des premi√®res lignes significatives
    console.log('\nüîç Analyse premi√®res lignes:');
    const lines = text.split('\n').map(line => line.trim()).filter(line => line.length > 0);
    
    for (let i = 0; i < Math.min(3, lines.length); i++) {
        const line = lines[i];
        
        // Ignorer les lignes avec des mots-cl√©s d'exclusion
        if (/^(qui sommes|nous|offre|entreprise|soci√©t√©|groupe)/i.test(line)) {
            console.log(`  ‚è≠Ô∏è Ligne ${i + 1} ignor√©e: "${line.substring(0, 30)}..."`);
            continue;
        }
        
        // Extraire le d√©but de la ligne comme titre potentiel
        let candidateTitle = line
            .replace(/[^\w\s√Ä-√ø\(\)\-]/g, ' ') // Garder seulement lettres, espaces, parenth√®ses, tirets
            .replace(/\s+/g, ' ') // Normaliser les espaces
            .trim();
        
        if (candidateTitle.length >= 5 && candidateTitle.length <= 50) {
            const finalTitle = candidateTitle.length <= 25 ? candidateTitle : candidateTitle.substring(0, 25);
            console.log(`  ‚úÖ Ligne ${i + 1} candidate: "${finalTitle}" (${finalTitle.length} caract√®res)`);
            return finalTitle;
        }
        
        console.log(`  ‚ùå Ligne ${i + 1} rejet√©e: "${line.substring(0, 30)}..." (longueur: ${candidateTitle.length})`);
    }
    
    // √âtape 3: Fallback garanti
    console.log('\n‚ö†Ô∏è Fallback activ√©');
    return 'Poste √† pourvoir';
}

// Fonction principale de test
async function testPDFParsing() {
    try {
        // V√©rifier si le fichier existe
        if (!fs.existsSync(PDF_PATH)) {
            console.log(`‚ùå Fichier non trouv√©: ${PDF_PATH}`);
            console.log('\nüí° Solutions possibles:');
            console.log('1. V√©rifiez le nom exact du fichier sur votre bureau');
            console.log('2. Modifiez le chemin PDF_PATH dans le script');
            console.log('3. D√©placez le PDF sur votre bureau avec le nom exact');
            return;
        }
        
        console.log('‚úÖ Fichier PDF trouv√©, lecture en cours...\n');
        
        // Lire et parser le PDF
        const dataBuffer = fs.readFileSync(PDF_PATH);
        const data = await pdf(dataBuffer);
        
        console.log(`üìÑ PDF lu avec succ√®s:`);
        console.log(`   - Pages: ${data.numpages}`);
        console.log(`   - Caract√®res: ${data.text.length}`);
        console.log(`   - Premi√®re ligne: "${data.text.split('\n')[0].substring(0, 100)}..."`);
        
        console.log('\n' + '='.repeat(50));
        console.log('üß™ TEST DES 4 STRAT√âGIES');
        console.log('='.repeat(50));
        
        // Tester les 4 strat√©gies
        const results = {
            pattern: extractTitleByPattern(data.text),
            firstLine: extractTitleByFirstLine(data.text),
            keywords: extractTitleByKeywords(data.text),
            multiPatterns: extractTitleMultiPatterns(data.text)
        };
        
        console.log('\n' + '='.repeat(50));
        console.log('üìä R√âSULTATS FINAUX');
        console.log('='.repeat(50));
        
        Object.entries(results).forEach(([strategy, result], index) => {
            const strategyNames = {
                pattern: 'Pattern exact',
                firstLine: 'Premi√®re ligne',
                keywords: 'Mots-cl√©s',
                multiPatterns: 'Multi-patterns'
            };
            
            console.log(`${index + 1}. ${strategyNames[strategy]}: "${result}" (${result.length} caract√®res)`);
        });
        
        console.log('\nüéØ RECOMMANDATION:');
        
        // Analyser les r√©sultats pour donner une recommandation
        const uniqueResults = [...new Set(Object.values(results))];
        
        if (uniqueResults.length === 1 && uniqueResults[0] === 'Poste √† pourvoir') {
            console.log('‚ö†Ô∏è Aucune strat√©gie n\'a r√©ussi √† extraire un titre sp√©cifique');
            console.log('üí° Il faut revoir l\'algorithme ou le contenu du PDF');
        } else {
            const nonFallbackResults = Object.entries(results).filter(([_, result]) => result !== 'Poste √† pourvoir');
            
            if (nonFallbackResults.length > 0) {
                const bestStrategy = nonFallbackResults[0];
                console.log(`‚úÖ Meilleure strat√©gie: ${bestStrategy[0]} ‚Üí "${bestStrategy[1]}"`);
                console.log('üí° Cette strat√©gie devrait √™tre int√©gr√©e dans JobParserAPI');
            }
        }
        
    } catch (error) {
        console.error('‚ùå Erreur lors du test:', error.message);
        
        if (error.message.includes('pdf-parse')) {
            console.log('\nüí° Solution: Installez pdf-parse avec: npm install pdf-parse');
        }
    }
}

// Lancer le test
testPDFParsing();