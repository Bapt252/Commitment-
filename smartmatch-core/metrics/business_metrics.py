"""
Métriques métier pour évaluer la qualité et l'impact business du matching.

Ce module calcule les métriques clés telles que taux de satisfaction,
conversion rates, ROI, temps d'embauche, etc.
"""

import logging
import statistics
from typing import List, Dict, Any, Optional, Tuple
from dataclasses import dataclass
from datetime import datetime, timedelta
from collections import defaultdict

from ..core.models import MatchResult

logger = logging.getLogger(__name__)


@dataclass
class BusinessMetricResult:
    """Résultat d'une métrique métier."""
    metric_name: str
    value: float
    unit: str
    period: str
    timestamp: datetime
    details: Dict[str, Any]
    trend: Optional[str] = None  # 'up', 'down', 'stable'


@dataclass
class ConversionFunnel:
    """Entonnoir de conversion du matching à l'embauche."""
    total_matches: int
    viewed_matches: int
    clicked_matches: int
    applied_matches: int
    interviews: int
    offers: int
    hires: int
    
    @property
    def view_rate(self) -> float:
        return self.viewed_matches / self.total_matches if self.total_matches > 0 else 0.0
    
    @property
    def click_rate(self) -> float:
        return self.clicked_matches / self.viewed_matches if self.viewed_matches > 0 else 0.0
    
    @property
    def application_rate(self) -> float:
        return self.applied_matches / self.clicked_matches if self.clicked_matches > 0 else 0.0
    
    @property
    def interview_rate(self) -> float:
        return self.interviews / self.applied_matches if self.applied_matches > 0 else 0.0
    
    @property
    def offer_rate(self) -> float:
        return self.offers / self.interviews if self.interviews > 0 else 0.0
    
    @property
    def hire_rate(self) -> float:
        return self.hires / self.offers if self.offers > 0 else 0.0
    
    @property
    def overall_conversion(self) -> float:
        return self.hires / self.total_matches if self.total_matches > 0 else 0.0


class BusinessMetrics:
    """
    Calcule et suit les métriques métier du système de matching.
    
    Métriques principales:
    - Taux de satisfaction candidat/recruteur
    - Taux de conversion (matching → embauche)
    - Temps moyen d'embauche
    - ROI du système de matching
    - Qualité des matches (précision, recall)
    - Engagement utilisateur
    """
    
    def __init__(self, 
                 db_connection=None,
                 config: Optional[Dict[str, Any]] = None):
        """
        Initialise le calculateur de métriques métier.
        
        Args:
            db_connection: Connection à la base de données
            config: Configuration spécifique
        """
        self.db = db_connection
        self.config = config or self._get_default_config()
        
        # Cache des métriques
        self.metrics_cache = {}
        self.cache_duration = timedelta(minutes=self.config.get('cache_duration_min', 15))
        
        # Historique des métriques
        self.metrics_history = defaultdict(list)
        
        logger.info(\"BusinessMetrics initialized\")\n    \n    def _get_default_config(self) -> Dict[str, Any]:\n        \"\"\"Configuration par défaut.\"\"\"\n        return {\n            'cache_duration_min': 15,\n            'satisfaction_scale': 5,  # Échelle 1-5\n            'nps_scale': 10,  # Échelle 0-10 pour NPS\n            'conversion_timeout_days': 90,  # Délai max pour conversion\n            'benchmark_periods': ['7d', '30d', '90d'],\n            'engagement_metrics': [\n                'views', 'clicks', 'applications', 'saves', 'shares'\n            ],\n            'quality_thresholds': {\n                'excellent_satisfaction': 4.5,\n                'good_satisfaction': 3.5,\n                'min_conversion_rate': 0.02,  # 2%\n                'max_time_to_hire_days': 45\n            }\n        }\n    \n    async def calculate_candidate_satisfaction(self, \n                                             period_days: int = 30,\n                                             segment: Optional[str] = None) -> BusinessMetricResult:\n        \"\"\"Calcule le taux de satisfaction candidat.\"\"\"\n        cache_key = f\"candidate_satisfaction_{period_days}_{segment}\"\n        \n        # Vérifier le cache\n        if self._is_cached(cache_key):\n            return self.metrics_cache[cache_key]\n        \n        try:\n            # Simuler la récupération des données de satisfaction\n            # En production, ceci interrogerait la base de données\n            satisfaction_data = await self._fetch_satisfaction_data(\n                user_type='candidate',\n                period_days=period_days,\n                segment=segment\n            )\n            \n            if not satisfaction_data:\n                result = BusinessMetricResult(\n                    metric_name='candidate_satisfaction',\n                    value=0.0,\n                    unit='score',\n                    period=f'{period_days}d',\n                    timestamp=datetime.now(),\n                    details={'data_points': 0, 'segment': segment}\n                )\n            else:\n                # Calculer la satisfaction moyenne\n                ratings = [d['rating'] for d in satisfaction_data]\n                avg_satisfaction = statistics.mean(ratings)\n                \n                # Normaliser sur une échelle 0-1\n                scale = self.config.get('satisfaction_scale', 5)\n                normalized_satisfaction = (avg_satisfaction - 1) / (scale - 1)\n                \n                # Calculer le NPS (Net Promoter Score) si disponible\n                nps_data = [d for d in satisfaction_data if 'nps_score' in d]\n                nps = self._calculate_nps(nps_data) if nps_data else None\n                \n                # Distribution des scores\n                score_distribution = self._calculate_score_distribution(ratings, scale)\n                \n                # Détails\n                details = {\n                    'data_points': len(satisfaction_data),\n                    'avg_rating': avg_satisfaction,\n                    'rating_distribution': score_distribution,\n                    'segment': segment\n                }\n                \n                if nps is not None:\n                    details['nps'] = nps\n                \n                # Tendance\n                trend = await self._calculate_satisfaction_trend(\n                    'candidate', period_days, segment\n                )\n                \n                result = BusinessMetricResult(\n                    metric_name='candidate_satisfaction',\n                    value=normalized_satisfaction,\n                    unit='score',\n                    period=f'{period_days}d',\n                    timestamp=datetime.now(),\n                    details=details,\n                    trend=trend\n                )\n            \n            # Mise en cache\n            self.metrics_cache[cache_key] = result\n            self.metrics_history['candidate_satisfaction'].append(result)\n            \n            return result\n            \n        except Exception as e:\n            logger.error(f\"Error calculating candidate satisfaction: {e}\")\n            return BusinessMetricResult(\n                metric_name='candidate_satisfaction',\n                value=0.0,\n                unit='score',\n                period=f'{period_days}d',\n                timestamp=datetime.now(),\n                details={'error': str(e)}\n            )\n    \n    async def calculate_recruiter_satisfaction(self, \n                                             period_days: int = 30,\n                                             segment: Optional[str] = None) -> BusinessMetricResult:\n        \"\"\"Calcule le taux de satisfaction recruteur.\"\"\"\n        cache_key = f\"recruiter_satisfaction_{period_days}_{segment}\"\n        \n        if self._is_cached(cache_key):\n            return self.metrics_cache[cache_key]\n        \n        try:\n            satisfaction_data = await self._fetch_satisfaction_data(\n                user_type='recruiter',\n                period_days=period_days,\n                segment=segment\n            )\n            \n            if not satisfaction_data:\n                result = BusinessMetricResult(\n                    metric_name='recruiter_satisfaction',\n                    value=0.0,\n                    unit='score',\n                    period=f'{period_days}d',\n                    timestamp=datetime.now(),\n                    details={'data_points': 0, 'segment': segment}\n                )\n            else:\n                ratings = [d['rating'] for d in satisfaction_data]\n                avg_satisfaction = statistics.mean(ratings)\n                \n                scale = self.config.get('satisfaction_scale', 5)\n                normalized_satisfaction = (avg_satisfaction - 1) / (scale - 1)\n                \n                # Métriques spécifiques recruteurs\n                quality_ratings = [d.get('quality_rating', 0) for d in satisfaction_data]\n                relevance_ratings = [d.get('relevance_rating', 0) for d in satisfaction_data]\n                \n                avg_quality = statistics.mean(quality_ratings) if quality_ratings else 0\n                avg_relevance = statistics.mean(relevance_ratings) if relevance_ratings else 0\n                \n                details = {\n                    'data_points': len(satisfaction_data),\n                    'avg_rating': avg_satisfaction,\n                    'avg_quality_rating': avg_quality,\n                    'avg_relevance_rating': avg_relevance,\n                    'segment': segment\n                }\n                \n                trend = await self._calculate_satisfaction_trend(\n                    'recruiter', period_days, segment\n                )\n                \n                result = BusinessMetricResult(\n                    metric_name='recruiter_satisfaction',\n                    value=normalized_satisfaction,\n                    unit='score',\n                    period=f'{period_days}d',\n                    timestamp=datetime.now(),\n                    details=details,\n                    trend=trend\n                )\n            \n            self.metrics_cache[cache_key] = result\n            self.metrics_history['recruiter_satisfaction'].append(result)\n            \n            return result\n            \n        except Exception as e:\n            logger.error(f\"Error calculating recruiter satisfaction: {e}\")\n            return BusinessMetricResult(\n                metric_name='recruiter_satisfaction',\n                value=0.0,\n                unit='score',\n                period=f'{period_days}d',\n                timestamp=datetime.now(),\n                details={'error': str(e)}\n            )\n    \n    async def calculate_conversion_rate(self, \n                                       matching_results: List[MatchResult],\n                                       period_days: int = 30) -> BusinessMetricResult:\n        \"\"\"Calcule le taux de conversion (entretiens, embauches).\"\"\"\n        cache_key = f\"conversion_rate_{period_days}_{len(matching_results)}\"\n        \n        if self._is_cached(cache_key):\n            return self.metrics_cache[cache_key]\n        \n        try:\n            # Construire l'entonnoir de conversion\n            funnel = await self._build_conversion_funnel(matching_results, period_days)\n            \n            # Calculer les taux de conversion\n            conversion_rates = {\n                'view_rate': funnel.view_rate,\n                'click_rate': funnel.click_rate,\n                'application_rate': funnel.application_rate,\n                'interview_rate': funnel.interview_rate,\n                'offer_rate': funnel.offer_rate,\n                'hire_rate': funnel.hire_rate,\n                'overall_conversion': funnel.overall_conversion\n            }\n            \n            # Score global (pondéré)\n            weighted_score = (\n                funnel.view_rate * 0.1 +\n                funnel.click_rate * 0.15 +\n                funnel.application_rate * 0.2 +\n                funnel.interview_rate * 0.25 +\n                funnel.offer_rate * 0.15 +\n                funnel.hire_rate * 0.15\n            )\n            \n            # Comparer aux benchmarks\n            benchmarks = await self._get_conversion_benchmarks()\n            \n            details = {\n                'funnel': {\n                    'total_matches': funnel.total_matches,\n                    'viewed': funnel.viewed_matches,\n                    'clicked': funnel.clicked_matches,\n                    'applied': funnel.applied_matches,\n                    'interviews': funnel.interviews,\n                    'offers': funnel.offers,\n                    'hires': funnel.hires\n                },\n                'conversion_rates': conversion_rates,\n                'benchmarks': benchmarks\n            }\n            \n            # Tendance\n            trend = await self._calculate_conversion_trend(period_days)\n            \n            result = BusinessMetricResult(\n                metric_name='conversion_rate',\n                value=weighted_score,\n                unit='rate',\n                period=f'{period_days}d',\n                timestamp=datetime.now(),\n                details=details,\n                trend=trend\n            )\n            \n            self.metrics_cache[cache_key] = result\n            self.metrics_history['conversion_rate'].append(result)\n            \n            return result\n            \n        except Exception as e:\n            logger.error(f\"Error calculating conversion rate: {e}\")\n            return BusinessMetricResult(\n                metric_name='conversion_rate',\n                value=0.0,\n                unit='rate',\n                period=f'{period_days}d',\n                timestamp=datetime.now(),\n                details={'error': str(e)}\n            )\n    \n    async def calculate_time_to_hire(self, \n                                   matched_candidates: List[Dict[str, Any]],\n                                   period_days: int = 90) -> BusinessMetricResult:\n        \"\"\"Calcule le temps moyen d'embauche.\"\"\"\n        cache_key = f\"time_to_hire_{period_days}_{len(matched_candidates)}\"\n        \n        if self._is_cached(cache_key):\n            return self.metrics_cache[cache_key]\n        \n        try:\n            hire_times = []\n            successful_hires = 0\n            \n            for candidate_data in matched_candidates:\n                if 'hired_date' in candidate_data and 'matched_date' in candidate_data:\n                    matched_date = candidate_data['matched_date']\n                    hired_date = candidate_data['hired_date']\n                    \n                    # Calculer le délai en jours\n                    if isinstance(matched_date, str):\n                        matched_date = datetime.fromisoformat(matched_date)\n                    if isinstance(hired_date, str):\n                        hired_date = datetime.fromisoformat(hired_date)\n                    \n                    time_to_hire = (hired_date - matched_date).days\n                    \n                    # Filtrer les valeurs aberrantes\n                    if 0 <= time_to_hire <= 365:  # Entre 0 et 1 an\n                        hire_times.append(time_to_hire)\n                        successful_hires += 1\n            \n            if not hire_times:\n                result = BusinessMetricResult(\n                    metric_name='time_to_hire',\n                    value=0.0,\n                    unit='days',\n                    period=f'{period_days}d',\n                    timestamp=datetime.now(),\n                    details={'successful_hires': 0}\n                )\n            else:\n                # Statistiques du temps d'embauche\n                avg_time = statistics.mean(hire_times)\n                median_time = statistics.median(hire_times)\n                p90_time = self._calculate_percentile(hire_times, 90)\n                \n                # Distribution\n                time_buckets = {\n                    '0-7_days': len([t for t in hire_times if t <= 7]),\n                    '8-30_days': len([t for t in hire_times if 8 <= t <= 30]),\n                    '31-60_days': len([t for t in hire_times if 31 <= t <= 60]),\n                    '60+_days': len([t for t in hire_times if t > 60])\n                }\n                \n                # Score normalisé (plus rapide = meilleur)\n                max_acceptable_days = self.config.get('quality_thresholds', {}).get(\n                    'max_time_to_hire_days', 45\n                )\n                normalized_score = max(0.0, 1.0 - (avg_time / max_acceptable_days))\n                \n                details = {\n                    'successful_hires': successful_hires,\n                    'avg_days': avg_time,\n                    'median_days': median_time,\n                    'p90_days': p90_time,\n                    'distribution': time_buckets,\n                    'total_candidates': len(matched_candidates)\n                }\n                \n                trend = await self._calculate_time_to_hire_trend(period_days)\n                \n                result = BusinessMetricResult(\n                    metric_name='time_to_hire',\n                    value=normalized_score,\n                    unit='days',\n                    period=f'{period_days}d',\n                    timestamp=datetime.now(),\n                    details=details,\n                    trend=trend\n                )\n            \n            self.metrics_cache[cache_key] = result\n            self.metrics_history['time_to_hire'].append(result)\n            \n            return result\n            \n        except Exception as e:\n            logger.error(f\"Error calculating time to hire: {e}\")\n            return BusinessMetricResult(\n                metric_name='time_to_hire',\n                value=0.0,\n                unit='days',\n                period=f'{period_days}d',\n                timestamp=datetime.now(),\n                details={'error': str(e)}\n            )\n    \n    async def calculate_roi_matching(self, \n                                   costs: Dict[str, float],\n                                   conversions: List[Dict[str, Any]],\n                                   period_days: int = 90) -> BusinessMetricResult:\n        \"\"\"Calcule le ROI du système de matching.\"\"\"\n        cache_key = f\"roi_matching_{period_days}_{len(conversions)}\"\n        \n        if self._is_cached(cache_key):\n            return self.metrics_cache[cache_key]\n        \n        try:\n            # Calculer les coûts totaux\n            total_costs = sum(costs.values())\n            \n            # Calculer les revenus/économies générés\n            total_revenue = 0.0\n            successful_placements = 0\n            \n            for conversion in conversions:\n                if conversion.get('hired', False):\n                    # Valeur d'un placement réussi\n                    placement_value = conversion.get('placement_value', 0)\n                    if placement_value > 0:\n                        total_revenue += placement_value\n                        successful_placements += 1\n                    else:\n                        # Utiliser une valeur estimée si pas spécifiée\n                        estimated_value = self._estimate_placement_value(conversion)\n                        total_revenue += estimated_value\n                        successful_placements += 1\n            \n            # Calculer le ROI\n            if total_costs > 0:\n                roi = (total_revenue - total_costs) / total_costs\n                roi_percentage = roi * 100\n            else:\n                roi = 0.0\n                roi_percentage = 0.0\n            \n            # Métriques complémentaires\n            cost_per_hire = total_costs / successful_placements if successful_placements > 0 else 0\n            revenue_per_hire = total_revenue / successful_placements if successful_placements > 0 else 0\n            \n            details = {\n                'total_costs': total_costs,\n                'cost_breakdown': costs,\n                'total_revenue': total_revenue,\n                'successful_placements': successful_placements,\n                'cost_per_hire': cost_per_hire,\n                'revenue_per_hire': revenue_per_hire,\n                'roi_percentage': roi_percentage\n            }\n            \n            # Score normalisé (ROI > 100% = score 1.0)\n            normalized_score = min(1.0, max(0.0, (roi + 1) / 2))  # Transformer [-1, 1] en [0, 1]\n            \n            trend = await self._calculate_roi_trend(period_days)\n            \n            result = BusinessMetricResult(\n                metric_name='roi_matching',\n                value=normalized_score,\n                unit='roi',\n                period=f'{period_days}d',\n                timestamp=datetime.now(),\n                details=details,\n                trend=trend\n            )\n            \n            self.metrics_cache[cache_key] = result\n            self.metrics_history['roi_matching'].append(result)\n            \n            return result\n            \n        except Exception as e:\n            logger.error(f\"Error calculating ROI: {e}\")\n            return BusinessMetricResult(\n                metric_name='roi_matching',\n                value=0.0,\n                unit='roi',\n                period=f'{period_days}d',\n                timestamp=datetime.now(),\n                details={'error': str(e)}\n            )\n    \n    async def calculate_engagement_metrics(self, \n                                         period_days: int = 30) -> BusinessMetricResult:\n        \"\"\"Calcule les métriques d'engagement utilisateur.\"\"\"\n        cache_key = f\"engagement_metrics_{period_days}\"\n        \n        if self._is_cached(cache_key):\n            return self.metrics_cache[cache_key]\n        \n        try:\n            # Récupérer les données d'engagement\n            engagement_data = await self._fetch_engagement_data(period_days)\n            \n            if not engagement_data:\n                result = BusinessMetricResult(\n                    metric_name='engagement_metrics',\n                    value=0.0,\n                    unit='score',\n                    period=f'{period_days}d',\n                    timestamp=datetime.now(),\n                    details={'data_points': 0}\n                )\n            else:\n                # Calculer les métriques d'engagement\n                metrics = {}\n                total_users = len(set(d['user_id'] for d in engagement_data))\n                \n                # Sessions par utilisateur\n                sessions_per_user = len(engagement_data) / total_users if total_users > 0 else 0\n                \n                # Temps moyen par session\n                session_durations = [d.get('duration_minutes', 0) for d in engagement_data]\n                avg_session_duration = statistics.mean(session_durations) if session_durations else 0\n                \n                # Actions par session\n                total_actions = sum(d.get('actions_count', 0) for d in engagement_data)\n                actions_per_session = total_actions / len(engagement_data) if engagement_data else 0\n                \n                # Taux de rebond (sessions avec une seule action)\n                single_action_sessions = len([d for d in engagement_data if d.get('actions_count', 0) <= 1])\n                bounce_rate = single_action_sessions / len(engagement_data) if engagement_data else 0\n                \n                # Score d'engagement composite\n                engagement_score = (\n                    min(1.0, sessions_per_user / 10) * 0.25 +  # Normaliser à 10 sessions max\n                    min(1.0, avg_session_duration / 30) * 0.25 +  # Normaliser à 30 min max\n                    min(1.0, actions_per_session / 20) * 0.25 +  # Normaliser à 20 actions max\n                    (1 - bounce_rate) * 0.25  # Moins de rebond = mieux\n                )\n                \n                details = {\n                    'total_users': total_users,\n                    'total_sessions': len(engagement_data),\n                    'sessions_per_user': sessions_per_user,\n                    'avg_session_duration_min': avg_session_duration,\n                    'actions_per_session': actions_per_session,\n                    'bounce_rate': bounce_rate,\n                    'engagement_score': engagement_score\n                }\n                \n                trend = await self._calculate_engagement_trend(period_days)\n                \n                result = BusinessMetricResult(\n                    metric_name='engagement_metrics',\n                    value=engagement_score,\n                    unit='score',\n                    period=f'{period_days}d',\n                    timestamp=datetime.now(),\n                    details=details,\n                    trend=trend\n                )\n            \n            self.metrics_cache[cache_key] = result\n            self.metrics_history['engagement_metrics'].append(result)\n            \n            return result\n            \n        except Exception as e:\n            logger.error(f\"Error calculating engagement metrics: {e}\")\n            return BusinessMetricResult(\n                metric_name='engagement_metrics',\n                value=0.0,\n                unit='score',\n                period=f'{period_days}d',\n                timestamp=datetime.now(),\n                details={'error': str(e)}\n            )\n    \n    async def get_comprehensive_report(self, \n                                     period_days: int = 30) -> Dict[str, BusinessMetricResult]:\n        \"\"\"Génère un rapport complet de toutes les métriques.\"\"\"\n        report = {}\n        \n        try:\n            # Calculer toutes les métriques principales\n            report['candidate_satisfaction'] = await self.calculate_candidate_satisfaction(period_days)\n            report['recruiter_satisfaction'] = await self.calculate_recruiter_satisfaction(period_days)\n            report['engagement'] = await self.calculate_engagement_metrics(period_days)\n            \n            # Métriques nécessitant des données spécifiques\n            # (en production, ces données viendraient de la base)\n            mock_matching_results = []  # À remplacer par de vraies données\n            mock_candidates = []  # À remplacer par de vraies données\n            mock_costs = {'platform': 1000, 'ai_processing': 500}  # À remplacer\n            mock_conversions = []  # À remplacer par de vraies données\n            \n            if mock_matching_results:\n                report['conversion_rate'] = await self.calculate_conversion_rate(\n                    mock_matching_results, period_days\n                )\n            \n            if mock_candidates:\n                report['time_to_hire'] = await self.calculate_time_to_hire(\n                    mock_candidates, period_days\n                )\n            \n            if mock_conversions:\n                report['roi'] = await self.calculate_roi_matching(\n                    mock_costs, mock_conversions, period_days\n                )\n            \n            logger.info(f\"Generated comprehensive report with {len(report)} metrics\")\n            return report\n            \n        except Exception as e:\n            logger.error(f\"Error generating comprehensive report: {e}\")\n            return {}\n    \n    # Méthodes utilitaires et privées\n    \n    def _is_cached(self, cache_key: str) -> bool:\n        \"\"\"Vérifie si une métrique est en cache et valide.\"\"\"\n        if cache_key not in self.metrics_cache:\n            return False\n        \n        metric = self.metrics_cache[cache_key]\n        age = datetime.now() - metric.timestamp\n        \n        return age < self.cache_duration\n    \n    async def _fetch_satisfaction_data(self, \n                                      user_type: str,\n                                      period_days: int,\n                                      segment: Optional[str] = None) -> List[Dict[str, Any]]:\n        \"\"\"Récupère les données de satisfaction (simulation).\"\"\"\n        # Simulation de données\n        # En production, ceci interrogerait la vraie base de données\n        \n        import random\n        \n        # Générer des données simulées\n        data = []\n        for i in range(random.randint(50, 200)):\n            data.append({\n                'user_id': f\"{user_type}_{i}\",\n                'rating': random.uniform(3.5, 4.8),\n                'nps_score': random.randint(7, 10),\n                'quality_rating': random.uniform(3.0, 5.0),\n                'relevance_rating': random.uniform(3.2, 4.9),\n                'timestamp': datetime.now() - timedelta(days=random.randint(0, period_days))\n            })\n        \n        return data\n    \n    async def _build_conversion_funnel(self, \n                                      matching_results: List[MatchResult],\n                                      period_days: int) -> ConversionFunnel:\n        \"\"\"Construit l'entonnoir de conversion (simulation).\"\"\"\n        total_matches = len(matching_results) or 1000  # Simulation\n        \n        # Données simulées basées sur des taux de conversion réalistes\n        viewed_matches = int(total_matches * 0.8)  # 80% des matches sont vus\n        clicked_matches = int(viewed_matches * 0.3)  # 30% des vus sont cliqués\n        applied_matches = int(clicked_matches * 0.15)  # 15% des clics mènent à candidature\n        interviews = int(applied_matches * 0.25)  # 25% des candidatures mènent à entretien\n        offers = int(interviews * 0.6)  # 60% des entretiens mènent à offre\n        hires = int(offers * 0.8)  # 80% des offres sont acceptées\n        \n        return ConversionFunnel(\n            total_matches=total_matches,\n            viewed_matches=viewed_matches,\n            clicked_matches=clicked_matches,\n            applied_matches=applied_matches,\n            interviews=interviews,\n            offers=offers,\n            hires=hires\n        )\n    \n    async def _fetch_engagement_data(self, period_days: int) -> List[Dict[str, Any]]:\n        \"\"\"Récupère les données d'engagement (simulation).\"\"\"\n        import random\n        \n        data = []\n        for i in range(random.randint(100, 500)):\n            data.append({\n                'user_id': f\"user_{random.randint(1, 100)}\",\n                'session_id': f\"session_{i}\",\n                'duration_minutes': random.uniform(2, 45),\n                'actions_count': random.randint(1, 25),\n                'timestamp': datetime.now() - timedelta(days=random.randint(0, period_days))\n            })\n        \n        return data\n    \n    def _calculate_nps(self, nps_data: List[Dict[str, Any]]) -> float:\n        \"\"\"Calcule le Net Promoter Score.\"\"\"\n        if not nps_data:\n            return 0.0\n        \n        scores = [d['nps_score'] for d in nps_data]\n        \n        promoters = len([s for s in scores if s >= 9])\n        detractors = len([s for s in scores if s <= 6])\n        total = len(scores)\n        \n        if total == 0:\n            return 0.0\n        \n        nps = ((promoters - detractors) / total) * 100\n        return nps\n    \n    def _calculate_score_distribution(self, \n                                     ratings: List[float], \n                                     scale: int) -> Dict[str, int]:\n        \"\"\"Calcule la distribution des scores.\"\"\"\n        distribution = {}\n        \n        for i in range(1, scale + 1):\n            count = len([r for r in ratings if i - 0.5 <= r < i + 0.5])\n            distribution[f\"{i}_stars\"] = count\n        \n        return distribution\n    \n    def _calculate_percentile(self, values: List[float], percentile: float) -> float:\n        \"\"\"Calcule un percentile.\"\"\"\n        if not values:\n            return 0.0\n        \n        sorted_values = sorted(values)\n        k = (len(sorted_values) - 1) * percentile / 100\n        floor_k = int(k)\n        ceil_k = floor_k + 1\n        \n        if ceil_k >= len(sorted_values):\n            return sorted_values[-1]\n        \n        d0 = sorted_values[floor_k] * (ceil_k - k)\n        d1 = sorted_values[ceil_k] * (k - floor_k)\n        \n        return d0 + d1\n    \n    def _estimate_placement_value(self, conversion: Dict[str, Any]) -> float:\n        \"\"\"Estime la valeur d'un placement.\"\"\"\n        # Estimation basée sur le salaire ou des données sectorielles\n        salary = conversion.get('salary', 50000)  # Salaire par défaut\n        \n        # Valeur estimée = pourcentage du salaire annuel\n        # (frais de recrutement typiques)\n        return salary * 0.15  # 15% du salaire\n    \n    async def _get_conversion_benchmarks(self) -> Dict[str, float]:\n        \"\"\"Récupère les benchmarks de conversion.\"\"\"\n        # Benchmarks industry standards (simulation)\n        return {\n            'view_rate': 0.75,\n            'click_rate': 0.25,\n            'application_rate': 0.12,\n            'interview_rate': 0.20,\n            'offer_rate': 0.50,\n            'hire_rate': 0.70,\n            'overall_conversion': 0.025  # 2.5%\n        }\n    \n    # Méthodes de calcul de tendances (simplifiées)\n    \n    async def _calculate_satisfaction_trend(self, \n                                          user_type: str,\n                                          period_days: int,\n                                          segment: Optional[str]) -> str:\n        \"\"\"Calcule la tendance de satisfaction.\"\"\"\n        # Simulation de tendance\n        import random\n        trends = ['up', 'down', 'stable']\n        return random.choice(trends)\n    \n    async def _calculate_conversion_trend(self, period_days: int) -> str:\n        \"\"\"Calcule la tendance de conversion.\"\"\"\n        import random\n        trends = ['up', 'down', 'stable']\n        return random.choice(trends)\n    \n    async def _calculate_time_to_hire_trend(self, period_days: int) -> str:\n        \"\"\"Calcule la tendance du temps d'embauche.\"\"\"\n        import random\n        trends = ['up', 'down', 'stable']\n        return random.choice(trends)\n    \n    async def _calculate_roi_trend(self, period_days: int) -> str:\n        \"\"\"Calcule la tendance du ROI.\"\"\"\n        import random\n        trends = ['up', 'down', 'stable']\n        return random.choice(trends)\n    \n    async def _calculate_engagement_trend(self, period_days: int) -> str:\n        \"\"\"Calcule la tendance d'engagement.\"\"\"\n        import random\n        trends = ['up', 'down', 'stable']\n        return random.choice(trends)\n    \n    def clear_cache(self) -> None:\n        \"\"\"Vide le cache des métriques.\"\"\"\n        self.metrics_cache.clear()\n        logger.info(\"Metrics cache cleared\")\n    \n    def get_metrics_history(self, metric_name: str) -> List[BusinessMetricResult]:\n        \"\"\"Retourne l'historique d'une métrique.\"\"\"\n        return self.metrics_history.get(metric_name, [])\n    \n    def export_metrics(self, \n                      period_days: int = 30,\n                      format: str = 'json') -> Dict[str, Any]:\n        \"\"\"Exporte les métriques pour analyse externe.\"\"\"\n        export_data = {\n            'export_timestamp': datetime.now().isoformat(),\n            'period_days': period_days,\n            'metrics': {},\n            'summary': {}\n        }\n        \n        # Exporter les métriques du cache\n        for key, metric in self.metrics_cache.items():\n            if f'{period_days}d' in key:\n                export_data['metrics'][metric.metric_name] = {\n                    'value': metric.value,\n                    'unit': metric.unit,\n                    'timestamp': metric.timestamp.isoformat(),\n                    'trend': metric.trend,\n                    'details': metric.details\n                }\n        \n        # Résumé\n        if export_data['metrics']:\n            export_data['summary'] = {\n                'total_metrics': len(export_data['metrics']),\n                'avg_timestamp': datetime.now().isoformat()\n            }\n        \n        return export_data\n"