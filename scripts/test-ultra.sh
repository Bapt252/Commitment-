#!/bin/bash
# üß™ PROMPT 2: Tests automatis√©s Parsers Ultra v2.0
# SuperSmartMatch V2 - Suite de tests compl√®te streaming temps r√©el

set -euo pipefail

# Configuration
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT="$(dirname "$SCRIPT_DIR")"
TEST_LOG="/tmp/test-ultra-$(date +%Y%m%d-%H%M%S).log"
TEST_DATA_DIR="$PROJECT_ROOT/test-data"

# URLs des services
CV_PARSER_URL="http://localhost:5051"
JOB_PARSER_URL="http://localhost:5053"
API_GATEWAY_URL="http://localhost:5050"
PROMETHEUS_URL="http://localhost:9091"
GRAFANA_URL="http://localhost:3001"

# Couleurs
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
PURPLE='\033[0;35m'
NC='\033[0m'

# Statistiques des tests
TESTS_TOTAL=0
TESTS_PASSED=0
TESTS_FAILED=0
TESTS_SKIPPED=0

# Logging
log() {
    echo -e "${BLUE}[$(date +'%H:%M:%S')]${NC} $1" | tee -a "$TEST_LOG"
}

log_success() {
    echo -e "${GREEN}‚úÖ $1${NC}" | tee -a "$TEST_LOG"
    ((TESTS_PASSED++))
}

log_failure() {
    echo -e "${RED}‚ùå $1${NC}" | tee -a "$TEST_LOG"
    ((TESTS_FAILED++))
}

log_skip() {
    echo -e "${YELLOW}‚è≠Ô∏è  $1${NC}" | tee -a "$TEST_LOG"
    ((TESTS_SKIPPED++))
}

# Fonction de test g√©n√©rique
run_test() {
    local test_name="$1"
    local test_function="$2"
    
    ((TESTS_TOTAL++))
    log "üß™ Test: $test_name"
    
    if $test_function; then
        log_success "$test_name"
        return 0
    else
        log_failure "$test_name"
        return 1
    fi
}

# Banner
show_banner() {
    echo -e "${PURPLE}"
    cat << "EOF"
‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë                                                              ‚ïë
‚ïë    üß™ SuperSmartMatch V2 - Tests Parsers Ultra v2.0         ‚ïë
‚ïë                                                              ‚ïë
‚ïë    PROMPT 2: Validation streaming temps r√©el + WebSocket    ‚ïë
‚ïë                                                              ‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù
EOF
    echo -e "${NC}"
}

# Pr√©paration des donn√©es de test
prepare_test_data() {
    log "üìÅ Pr√©paration des donn√©es de test..."
    
    mkdir -p "$TEST_DATA_DIR"
    
    # Cr√©ation d'un CV de test si absent
    if [[ ! -f "$TEST_DATA_DIR/sample-cv.txt" ]]; then
        cat > "$TEST_DATA_DIR/sample-cv.txt" << 'EOF'
Jean Dupont
D√©veloppeur Full Stack Senior

Email: jean.dupont@email.com
T√©l√©phone: +33 6 12 34 56 78
Adresse: 123 Rue de la Paix, 75001 Paris

COMP√âTENCES TECHNIQUES:
- JavaScript, TypeScript, React, Node.js
- Python, Django, FastAPI
- PostgreSQL, MongoDB, Redis
- Docker, Kubernetes, AWS
- Git, Jenkins, CI/CD

SOFT SKILLS:
- Leadership d'√©quipe
- Communication efficace
- R√©solution de probl√®mes
- Travail en √©quipe
- Adaptabilit√©

EXP√âRIENCE PROFESSIONNELLE:
2020-2023: Lead Developer chez TechCorp
- D√©veloppement d'applications web modernes
- Management d'une √©quipe de 5 d√©veloppeurs
- Mise en place de l'architecture microservices

2018-2020: Full Stack Developer chez StartupXYZ
- D√©veloppement de la plateforme e-commerce
- Optimisation des performances
- Int√©gration d'APIs tierces

FORMATION:
2018: Master en Informatique - √âcole Polytechnique
2016: Licence en Informatique - Universit√© Paris Diderot

CERTIFICATIONS:
- AWS Solutions Architect
- Certified Kubernetes Administrator
- Scrum Master Certified

LANGUES:
- Fran√ßais: Natif
- Anglais: Courant
- Espagnol: Interm√©diaire
EOF
    fi
    
    # Cr√©ation d'une offre d'emploi de test si absente
    if [[ ! -f "$TEST_DATA_DIR/sample-job.txt" ]]; then
        cat > "$TEST_DATA_DIR/sample-job.txt" << 'EOF'
D√©veloppeur Backend Senior - Python/Django
CDI - Paris 75001

NOTRE ENTREPRISE:
TechInnovation est une scale-up fran√ßaise sp√©cialis√©e dans l'IA et le machine learning.
Nous d√©veloppons des solutions innovantes pour les entreprises du CAC 40.

POSTE:
Nous recherchons un D√©veloppeur Backend Senior pour rejoindre notre √©quipe technique.
Vous serez en charge du d√©veloppement de nos APIs et de l'architecture backend.

MISSIONS PRINCIPALES:
- D√©veloppement d'APIs REST en Python/Django
- Conception et optimisation de bases de donn√©es
- Int√©gration de services de machine learning
- Collaboration avec les √©quipes frontend et data science
- Encadrement technique des d√©veloppeurs junior
- Participation aux choix d'architecture

COMP√âTENCES REQUISES:
- Python (5+ ans d'exp√©rience)
- Django/FastAPI
- PostgreSQL/MongoDB
- Redis
- Docker
- Git
- Tests unitaires et int√©gration
- Architecture microservices

COMP√âTENCES SOUHAIT√âES:
- Machine Learning (scikit-learn, TensorFlow)
- Kubernetes
- AWS/GCP
- Elasticsearch
- GraphQL
- React (notions)

PROFIL RECHERCH√â:
- 5+ ann√©es d'exp√©rience en d√©veloppement backend
- Master en informatique ou √©quivalent
- Anglais technique courant
- Esprit d'√©quipe et curiosit√© technique
- Exp√©rience en startup/scale-up appr√©ci√©e

CONDITIONS:
- Salaire: 55k‚Ç¨ - 75k‚Ç¨ selon exp√©rience
- T√©l√©travail hybride (2-3j/semaine)
- Tickets restaurant
- Mutuelle d'entreprise
- Formation continue
- Stock-options

LOCALISATION:
Paris 1er arrondissement
M√©tro: Ch√¢telet-Les Halles
T√©l√©travail partiel possible

TYPE DE CONTRAT: CDI
EXP√âRIENCE MINIMALE: 5 ans
SECTEUR: Technologie/IA
TAILLE ENTREPRISE: Scale-up (50-200 employ√©s)
EOF
    fi
    
    log_success "Donn√©es de test pr√©par√©es"
}

# Tests des services de base
test_services_health() {
    log "üè• Test de sant√© des services..."
    
    local services=(
        "$CV_PARSER_URL/health"
        "$JOB_PARSER_URL/health"
        "$API_GATEWAY_URL/health"
        "$PROMETHEUS_URL/-/healthy"
        "$GRAFANA_URL/api/health"
    )
    
    for service in "${services[@]}"; do
        if curl -sf "$service" >/dev/null 2>&1; then
            log_success "Service ${service} OK"
        else
            log_failure "Service ${service} inaccessible"
            return 1
        fi
    done
    
    return 0
}

# Test de parsing CV avec WebSocket
test_cv_parsing_websocket() {
    log "‚ö° Test CV Parser Ultra avec WebSocket..."
    
    # Lancer le parsing CV
    local response=$(curl -s -X POST \
        -F "file=@$TEST_DATA_DIR/sample-cv.txt" \
        "$CV_PARSER_URL/v2/parse/cv/stream")
    
    # V√©rifier la r√©ponse
    if ! echo "$response" | grep -q "task_id"; then
        log_failure "Pas de task_id dans la r√©ponse CV"
        return 1
    fi
    
    local task_id=$(echo "$response" | jq -r '.task_id' 2>/dev/null)
    if [[ -z "$task_id" || "$task_id" == "null" ]]; then
        log_failure "Task ID invalide pour CV"
        return 1
    fi
    
    log "Task ID CV: $task_id"
    
    # Test WebSocket (simulation avec curl pour status)
    sleep 2
    local status_response=$(curl -s "$CV_PARSER_URL/v2/parse/validate/$task_id")
    
    if echo "$status_response" | grep -q "task_id"; then
        log_success "WebSocket CV - Status endpoint OK"
    else
        log_failure "WebSocket CV - Status endpoint KO"
        return 1
    fi
    
    return 0
}

# Test de parsing Job avec WebSocket
test_job_parsing_websocket() {
    log "üéØ Test Job Parser Ultra avec WebSocket..."
    
    # Lancer le parsing Job
    local response=$(curl -s -X POST \
        -F "file=@$TEST_DATA_DIR/sample-job.txt" \
        "$JOB_PARSER_URL/v2/parse/job/stream")
    
    # V√©rifier la r√©ponse
    if ! echo "$response" | grep -q "task_id"; then
        log_failure "Pas de task_id dans la r√©ponse Job"
        return 1
    fi
    
    local task_id=$(echo "$response" | jq -r '.task_id' 2>/dev/null)
    if [[ -z "$task_id" || "$task_id" == "null" ]]; then
        log_failure "Task ID invalide pour Job"
        return 1
    fi
    
    log "Task ID Job: $task_id"
    
    # Test WebSocket (simulation)
    sleep 2
    local status_response=$(curl -s "$JOB_PARSER_URL/v2/parse/job/validate/$task_id")
    
    if echo "$status_response" | grep -q "task_id"; then
        log_success "WebSocket Job - Status endpoint OK"
    else
        log_failure "WebSocket Job - Status endpoint KO"
        return 1
    fi
    
    return 0
}

# Test des m√©triques Prometheus
test_prometheus_metrics() {
    log "üìä Test des m√©triques Prometheus..."
    
    # Attendre que les m√©triques soient collect√©es
    sleep 5
    
    local metrics=(
        "cv_parsing_requests_total"
        "job_parsing_requests_total"
        "cv_websocket_connections_active"
        "job_websocket_connections_active"
        "cv_parsing_duration_seconds"
        "job_parsing_duration_seconds"
    )
    
    for metric in "${metrics[@]}"; do
        local query_result=$(curl -s "$PROMETHEUS_URL/api/v1/query?query=$metric")
        
        if echo "$query_result" | grep -q '"status":"success"'; then
            log_success "M√©trique $metric disponible"
        else
            log_failure "M√©trique $metric manquante"
            return 1
        fi
    done
    
    return 0
}

# Test de performance et latence
test_performance() {
    log "‚ö° Test de performance des parsers..."
    
    local start_time
    local end_time
    local duration
    
    # Test latence CV Parser
    start_time=$(date +%s.%N)
    curl -s -X POST \
        -F "file=@$TEST_DATA_DIR/sample-cv.txt" \
        "$CV_PARSER_URL/v2/parse/cv/stream" >/dev/null
    end_time=$(date +%s.%N)
    duration=$(echo "$end_time - $start_time" | bc -l)
    
    if (( $(echo "$duration < 3.0" | bc -l) )); then
        log_success "CV Parser latence OK: ${duration}s"
    else
        log_failure "CV Parser latence √©lev√©e: ${duration}s"
        return 1
    fi
    
    # Test latence Job Parser
    start_time=$(date +%s.%N)
    curl -s -X POST \
        -F "file=@$TEST_DATA_DIR/sample-job.txt" \
        "$JOB_PARSER_URL/v2/parse/job/stream" >/dev/null
    end_time=$(date +%s.%N)
    duration=$(echo "$end_time - $start_time" | bc -l)
    
    if (( $(echo "$duration < 2.0" | bc -l) )); then
        log_success "Job Parser latence OK: ${duration}s"
    else
        log_failure "Job Parser latence √©lev√©e: ${duration}s"
        return 1
    fi
    
    return 0
}

# Test de charge simple
test_load() {
    log "üî• Test de charge des parsers..."
    
    local concurrent_requests=5
    local pids=()
    
    # Lancement de requ√™tes concurrentes
    for i in $(seq 1 $concurrent_requests); do
        {
            curl -s -X POST \
                -F "file=@$TEST_DATA_DIR/sample-cv.txt" \
                "$CV_PARSER_URL/v2/parse/cv/stream" >/dev/null
        } &
        pids+=($!)
    done
    
    # Attendre la fin de toutes les requ√™tes
    local all_success=true
    for pid in "${pids[@]}"; do
        if ! wait $pid; then
            all_success=false
        fi
    done
    
    if $all_success; then
        log_success "Test de charge: $concurrent_requests requ√™tes concurrentes OK"
    else
        log_failure "Test de charge: √©chec de certaines requ√™tes"
        return 1
    fi
    
    return 0
}

# Test des formats de fichiers
test_file_formats() {
    log "üìÑ Test des formats de fichiers support√©s..."
    
    # Cr√©er des fichiers de test de diff√©rents formats
    echo "Test CV content" > "$TEST_DATA_DIR/test-cv.txt"
    echo "Test Job content" > "$TEST_DATA_DIR/test-job.html"
    
    # Test format TXT pour CV
    local txt_response=$(curl -s -X POST \
        -F "file=@$TEST_DATA_DIR/test-cv.txt" \
        "$CV_PARSER_URL/v2/parse/cv/stream")
    
    if echo "$txt_response" | grep -q "task_id"; then
        log_success "Format TXT support√© pour CV"
    else
        log_failure "Format TXT non support√© pour CV"
        return 1
    fi
    
    # Test format HTML pour Job
    local html_response=$(curl -s -X POST \
        -F "file=@$TEST_DATA_DIR/test-job.html" \
        "$JOB_PARSER_URL/v2/parse/job/stream")
    
    if echo "$html_response" | grep -q "task_id"; then
        log_success "Format HTML support√© pour Job"
    else
        log_failure "Format HTML non support√© pour Job"
        return 1
    fi
    
    return 0
}

# Test de gestion d'erreurs
test_error_handling() {
    log "üö´ Test de gestion d'erreurs..."
    
    # Test avec fichier trop gros (simulation)
    local large_file_response=$(curl -s -X POST \
        -F "file=@$TEST_DATA_DIR/sample-cv.txt" \
        -H "Content-Length: 99999999" \
        "$CV_PARSER_URL/v2/parse/cv/stream")
    
    # Le service devrait g√©rer l'erreur proprement
    if echo "$large_file_response" | grep -q -E "(error|413|too large)"; then
        log_success "Gestion d'erreur fichier volumineux OK"
    else
        log_skip "Test fichier volumineux (r√©ponse: ${large_file_response:0:50}...)"
    fi
    
    # Test avec format non support√©
    echo "test" > "$TEST_DATA_DIR/test.xyz"
    local unsupported_response=$(curl -s -X POST \
        -F "file=@$TEST_DATA_DIR/test.xyz" \
        "$CV_PARSER_URL/v2/parse/cv/stream")
    
    if echo "$unsupported_response" | grep -q -E "(error|400|unsupported|non support√©)"; then
        log_success "Gestion d'erreur format non support√© OK"
    else
        log_skip "Test format non support√© (r√©ponse: ${unsupported_response:0:50}...)"
    fi
    
    return 0
}

# Test d'int√©gration avec l'API Gateway
test_api_gateway_integration() {
    log "üåê Test d'int√©gration API Gateway..."
    
    # Test routage vers CV Parser via Gateway
    local gateway_cv_response=$(curl -s -X POST \
        -F "file=@$TEST_DATA_DIR/sample-cv.txt" \
        "$API_GATEWAY_URL/api/v2/parse/cv/stream")
    
    if echo "$gateway_cv_response" | grep -q "task_id"; then
        log_success "Routage API Gateway vers CV Parser OK"
    else
        log_failure "Routage API Gateway vers CV Parser KO"
        return 1
    fi
    
    # Test routage vers Job Parser via Gateway
    local gateway_job_response=$(curl -s -X POST \
        -F "file=@$TEST_DATA_DIR/sample-job.txt" \
        "$API_GATEWAY_URL/api/v2/parse/job/stream")
    
    if echo "$gateway_job_response" | grep -q "task_id"; then
        log_success "Routage API Gateway vers Job Parser OK"
    else
        log_failure "Routage API Gateway vers Job Parser KO"
        return 1
    fi
    
    return 0
}

# Nettoyage des fichiers de test
cleanup_test_data() {
    log "üßπ Nettoyage des fichiers de test..."
    
    rm -f "$TEST_DATA_DIR/test-cv.txt"
    rm -f "$TEST_DATA_DIR/test-job.html"
    rm -f "$TEST_DATA_DIR/test.xyz"
    
    log_success "Nettoyage termin√©"
}

# G√©n√©ration du rapport de tests
generate_test_report() {
    log "üìã G√©n√©ration du rapport de tests..."
    
    local success_rate=0
    if [[ $TESTS_TOTAL -gt 0 ]]; then
        success_rate=$(( (TESTS_PASSED * 100) / TESTS_TOTAL ))
    fi
    
    echo ""
    echo -e "${PURPLE}‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó${NC}"
    echo -e "${PURPLE}‚ïë         RAPPORT DE TESTS ULTRA v2.0     ‚ïë${NC}"
    echo -e "${PURPLE}‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù${NC}"
    echo ""
    echo -e "${BLUE}üìä Statistiques:${NC}"
    echo -e "  Total des tests:      $TESTS_TOTAL"
    echo -e "  ${GREEN}Tests r√©ussis:        $TESTS_PASSED${NC}"
    echo -e "  ${RED}Tests √©chou√©s:        $TESTS_FAILED${NC}"
    echo -e "  ${YELLOW}Tests ignor√©s:        $TESTS_SKIPPED${NC}"
    echo -e "  ${PURPLE}Taux de r√©ussite:     $success_rate%${NC}"
    echo ""
    
    if [[ $success_rate -ge 90 ]]; then
        echo -e "${GREEN}üéâ EXCELLENT! Les parsers Ultra v2.0 fonctionnent parfaitement!${NC}"
    elif [[ $success_rate -ge 75 ]]; then
        echo -e "${YELLOW}‚ö†Ô∏è  BON. Quelques am√©liorations possibles.${NC}"
    else
        echo -e "${RED}‚ùå ATTENTION. Des probl√®mes d√©tect√©s n√©cessitent investigation.${NC}"
    fi
    
    echo ""
    echo -e "${BLUE}üìù Log d√©taill√©: $TEST_LOG${NC}"
    echo ""
}

# Fonction principale
main() {
    show_banner
    
    log "üöÄ D√©but des tests Parsers Ultra v2.0"
    log "üìù Log d√©taill√©: $TEST_LOG"
    
    prepare_test_data
    
    # Tests de base
    run_test "Services Health Check" test_services_health
    
    # Tests de parsing
    run_test "CV Parsing WebSocket" test_cv_parsing_websocket
    run_test "Job Parsing WebSocket" test_job_parsing_websocket
    
    # Tests de monitoring
    run_test "M√©triques Prometheus" test_prometheus_metrics
    
    # Tests de performance
    run_test "Performance et Latence" test_performance
    run_test "Test de Charge" test_load
    
    # Tests de fonctionnalit√©s
    run_test "Formats de Fichiers" test_file_formats
    run_test "Gestion d'Erreurs" test_error_handling
    
    # Tests d'int√©gration
    run_test "Int√©gration API Gateway" test_api_gateway_integration
    
    cleanup_test_data
    generate_test_report
    
    # Code de sortie bas√© sur les r√©sultats
    if [[ $TESTS_FAILED -eq 0 ]]; then
        log_success "üéâ Tous les tests sont pass√©s avec succ√®s!"
        exit 0
    else
        log_failure "‚ùå $TESTS_FAILED test(s) ont √©chou√©"
        exit 1
    fi
}

# Gestion des arguments
case "${1:-all}" in
    "all")
        main
        ;;
    "health")
        show_banner
        prepare_test_data
        run_test "Services Health Check" test_services_health
        generate_test_report
        ;;
    "parsing")
        show_banner
        prepare_test_data
        run_test "CV Parsing WebSocket" test_cv_parsing_websocket
        run_test "Job Parsing WebSocket" test_job_parsing_websocket
        generate_test_report
        ;;
    "performance")
        show_banner
        prepare_test_data
        run_test "Performance et Latence" test_performance
        run_test "Test de Charge" test_load
        generate_test_report
        ;;
    "integration")
        show_banner
        prepare_test_data
        run_test "Int√©gration API Gateway" test_api_gateway_integration
        generate_test_report
        ;;
    *)
        echo "Usage: $0 {all|health|parsing|performance|integration}"
        echo ""
        echo "  all          - Ex√©cute tous les tests"
        echo "  health       - Test de sant√© des services"
        echo "  parsing      - Tests de parsing CV et Job"
        echo "  performance  - Tests de performance"
        echo "  integration  - Tests d'int√©gration"
        exit 1
        ;;
esac
